<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>计算机网络第六章 应用层</title>
    <link href="/2024/06/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC%E5%85%AD%E7%AB%A0-%E5%BA%94%E7%94%A8%E5%B1%82/"/>
    <url>/2024/06/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC%E5%85%AD%E7%AB%A0-%E5%BA%94%E7%94%A8%E5%B1%82/</url>
    
    <content type="html"><![CDATA[<h2 id="一-域名系统dns"><a class="markdownIt-Anchor" href="#一-域名系统dns"></a> 一、域名系统DNS</h2><h3 id="1-互联网的域名结构"><a class="markdownIt-Anchor" href="#1-互联网的域名结构"></a> 1、互联网的域名结构</h3><ul><li>互联网采用层次树状结构的域名结构。</li><li>域名的结构由若干个分量组成，各分量之间用“点”隔开，分别代表不同级别的域名。<ul><li>每一级的域名都由英文字母和数字组成，不超过63个字符，不区分大小写字母。</li><li>级别最低的域名写在最左边，而级别最高的顶级域名写在最右边。</li><li>完整的域名不超过255个字符。</li></ul></li><li>域名系统既不规定一个域名需要包含多少个下级域名，也不规定每一级的域名代表什么意思。</li><li>各级域名由其上一级的域名管理机构管理，顶级域名由ICANN进行管理。</li><li>域名只是个<strong>逻辑概念</strong>，并不代表计算机所在的物理地点。</li><li>变长的域名和使用有助记忆的字符串，是为了便于人来使用。</li><li>IP地址是定长的32位二进制数字则非常便于机器进行处理。</li><li>域名中的“点”和点分十进制 IP 地址中的“点”<strong>并无一一对应的关系</strong>。<ul><li>点分十进制IP地址中一定是包含三个“点”。</li><li>域名中“点”的数目则不一定正好是三个。</li></ul></li><li>顶级域名（Top Level Domain，TLD）分为以下三类：<ul><li>国家顶级域名nTLD：cn</li><li>通用顶级域名gTLD：com、edu</li><li>基础结构域名arpa：用于反向域名解析，即IP地址反向解析为域名，又称反向域名。</li></ul></li><li>在国家顶级域名下注册的二级域名均由该国家自行确定。例如，顶级域名为jp的日本，将其教育和企业机构的二级域名定为ac和co，而不用edu和com。</li><li>中国则将二级域名划分为以下两类：<ul><li>类别域名：共七个：ac（科研机构）、com（工、商、金融等企业）、edu（教育机构）、 gov（政府部门）、net（提供网络服务的机构）、mil（军事机构）和 org（非 营利性组织）。</li><li>行政区域名：共34个，适用于我国的各省、自治区、直辖市。例如：bj为北京市、sh为上海 市、js为江苏省，等等。</li></ul></li><li>这种按等级管理的命名方法便于维护名字的唯一性，并且也容易设计出一种高效的域名查询机制。</li></ul><h3 id="2-域名服务器"><a class="markdownIt-Anchor" href="#2-域名服务器"></a> 2、域名服务器</h3><ul><li>一个服务器所负责管辖的（或有权限的）范围叫做区（zone）。</li><li>各单位根据具体情况来划分自己管辖范围的区。但在一个区中的所有节点必须是能够连通的。</li><li>每一个区设置相应的权限域名服务器，用来保存该区中的<strong>所有主机的域名到IP地址的映射</strong>。</li><li><strong>DNS服务器的管辖范围不是以“域”为单位，而是以“区”为单位</strong>。</li><li>域名和IP地址的映射关系必须保存在域名服务器中，供所有其他应用查询。</li><li>显然不能将所有信息都储存在一台域名服务器中。</li><li>DNS使用分布在各地的域名服务器来实现域名到IP地址的转换。</li></ul><h4 id="根域名服务器"><a class="markdownIt-Anchor" href="#根域名服务器"></a> 根域名服务器</h4><ul><li>根域名服务器是<strong>最高层次的域名服务器</strong>。</li><li>每个根域名服务器都知道所有的<strong>顶级域名服务器</strong>的域名及其IP地址。</li><li>在互联网上共有13个（套）不同IP地址的根域名服务器，名字是用一个英文字母命名，从a一直到m。</li><li>尽管我们将这13个根域名服务器中的每一个都视为单个的服务器，但“每台服务器”实际上是由许多分布在世界各地的计算机构成的服务器群集。<ul><li>不管是哪一个本地域名服务器，若要对互联网上任何一个域名进行解析，只要自己无法解析，就首先求助于根域名服务器。</li><li>当本地域名服务器向根域名服务器发出查询请求时，路由器就把查询请求报文<strong>转发到离这个DNS客户最近的一个根域名服务器</strong>。</li><li>这就加快了DNS的查询过程，同时也更合理地利用了互联网的资源。根域名服务器通常并不直接对域名进行解析，而是<strong>返回该域名所属顶级域名的顶级域名服务器的IP地址</strong>。</li></ul></li></ul><h4 id="顶级域名服务器"><a class="markdownIt-Anchor" href="#顶级域名服务器"></a> 顶级域名服务器</h4><ul><li>顶级域名服务器（即TLD服务器）负责管理在该顶级域名服务器注册的所有二级域名。</li><li>当收到DNS查询请求时就给出相应的回答<ul><li>可能是最后的结果。</li><li>也可能是下一级权限域名服务器的IP地址。</li></ul></li></ul><h4 id="权限域名服务器"><a class="markdownIt-Anchor" href="#权限域名服务器"></a> 权限域名服务器</h4><ul><li>权限域名服务器负责管理某个区的域名。</li><li>每一个主机的域名都必须在某个权限域名服务器处注册登记。因此权限域名服务器知道其管辖的域名与IP地址的映射关系。</li><li>权限域名服务器还知道其下级域名服务器的地址。</li><li>当一个权限域名服务器还不能给出最后的查询回答时，就会告诉发出查询请求的DNS客户，下一步应当找哪一个权限域名服务器。</li></ul><h4 id="本地域名服务器"><a class="markdownIt-Anchor" href="#本地域名服务器"></a> 本地域名服务器</h4><ul><li>本地域名服务器不属于上述的域名服务器的等级结构。</li><li>当一个主机发出DNS请求报文时，这个报文就<strong>首先被送往该主机的本地域名服务器</strong>。</li><li>本地域名服务器起着代理的作用，会将该报文转发到上述的域名服务器的等级结构中。</li><li>每一个互联网服务提供者ISP，一个大学，甚至一个大学里的学院，都可以拥有一个本地域名服务器，它有时也称为默认域名服务器。</li><li>本地域名服务器离用户较近，一般不超过几个路由器的距离，也有可能就在同一个局域网中。</li><li>本地域名服务器的IP地址需要直接配置在需要域名解析的主机中。</li></ul><h4 id="提高域名服务器的可靠性"><a class="markdownIt-Anchor" href="#提高域名服务器的可靠性"></a> 提高域名服务器的可靠性</h4><ul><li><p>DNS域名服务器都把数据<strong>复制到几个域名服务器来保存</strong>，其中的一个是主域名服务器，其他的是辅助域名服务器。</p></li><li><p>当主域名服务器出故障时，辅助域名服务器可以保证DNS的查询工作不会中断。</p></li><li><p>保证数据的一致性：</p><ul><li>主域名服务器定期把数据复制到辅助域名服务器中。</li><li>更改数据只能在主域名服务器中进行。</li></ul></li></ul><h3 id="3-域名解析过程"><a class="markdownIt-Anchor" href="#3-域名解析过程"></a> 3、域名解析过程</h3><ul><li><strong>主机向本地域名服务器的查询一般都是采用递归查询</strong>。<ul><li>如果主机所询问的本地域名服务器不知道被查询域名的IP地址，那么本地域名服务器就以DNS客户的身份，向其他根域名服务器继续发出查询请求报文。</li></ul></li><li><strong>本地域名服务器向根域名服务器的查询通常是采用迭代查询</strong>。<ul><li>当根域名服务器收到本地域名服务器的迭代查询请求报文时，要么给出所要查询的IP地址，要么告诉本地域名服务器：“你下一步应当向哪一个域名服务器进行查询”。然后让本地域名服务器进行后续的查询。</li></ul></li></ul><img src="/2024/06/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC%E5%85%AD%E7%AB%A0-%E5%BA%94%E7%94%A8%E5%B1%82/1.png" class=""><ul><li><p>如果不久前已经有用户查 询过域名y.abc.com的IP地址， 则本地域名服务器的高速缓存 中应该有该域名对应的IP地址。直接把高速缓存中存放的上次查询 结果（即y.abc.com的IP地址）告诉用户即可。</p></li><li><p>为了提高DNS的查询效率，并减轻根域名服务器的负荷和减少互联网上的DNS查询报文数量，<strong>在域名服务器中广泛地使用了高速缓存</strong>。<strong>高速缓存用来存放最近查询过的域名以及从何处获得域名映射信息的记录</strong>。</p></li><li><p>由于域名到IP地址的映射关系并不是永久不变，为保持高速缓存中的内容正确，<strong>域名服务器应为每项内容设置计时器</strong>并删除超过合理时间的项（例如，每个项目只存放两天）。</p></li><li><p>当权限域名服务器回答一个查询请求时，在响应中都指明绑定有效存在的时间值。增加此时间值可减少网络开销，而减少此时间值可提高域名转换的准确性。</p></li><li><p>不但在本地域名服务器中需要高速缓存，在用户主机中也很需要。许多用户主机在启动时从本地域名服务器下载域名和IP地址的全部数据库，维护存放自己最近使用的域名的高速缓存，并且只在从缓存中找不到域名时才向域名服务器查询。同理，主机也需要保持高速缓存中内容的正确性。</p></li></ul><h2 id="二-万维网www"><a class="markdownIt-Anchor" href="#二-万维网www"></a> 二、万维网WWW</h2><h3 id="1-统一资源定位符url"><a class="markdownIt-Anchor" href="#1-统一资源定位符url"></a> 1、统一资源定位符URL</h3><ul><li>为了方便访问在世界范围的文档，使用统一资源定位符URL来指明任何种类“资源”的位置。</li><li>统一资源定位符URL是对可以从互联网上得到的<strong>资源的位置和访问方法</strong>的一种简洁表示。</li><li>只要能够对资源定位，系统就可以对资源进行各种操作，如存取、更新、替换和查找其属性。</li><li>URL相当于一个文件名在网络范围的扩展。</li><li>URL是与互联网相连的机器上的<strong>任何可访问对象的一个指针</strong>。</li><li>URL的一般形式由以下四个部分组成（由以冒号隔开的两大部分组成，对大小写没有要求）：<ul><li>&lt;协议&gt;://&lt;主机&gt;:&lt;端口&gt;/&lt;路径&gt;</li><li>&lt;主机&gt; 是存放资源的主机在互联网中的域名</li></ul></li><li>现在有些浏览器为了方便用户，在输入URL时可把最前面的http://，甚至把主机名最前面的www省略，然后浏览器替用户把省略的字符添上。</li></ul><h3 id="2-超文本传送协议http"><a class="markdownIt-Anchor" href="#2-超文本传送协议http"></a> 2、超文本传送协议HTTP</h3><ul><li>HTTP定义了浏览器（即万维网客户进程）怎样向万维网服务器请求万维网文档，以及万维网服务器怎样把万维网文档传送给浏览器。</li><li>为了使超文本的链接能够高效率地完成，需要用HTTP协议来传送一切必须的信息。</li><li>从层次的角度看，<strong>HTTP是面向事务的（transaction-oriented）应用层协议</strong>，它是万维网上能够可靠地交换文件（包括文本、声音、图像等各种多媒体文件）的重要基础。</li><li>HTTP/1.0采用<strong>非持续连接方式</strong>。在该方式下，每次浏览器要请求一个文件都要与服务器建立TCP 连接，当收到响应后就立即关闭连接。<strong>HTTP/1.0协议是无状态的</strong>。<ul><li>每请求一个文档就要有两倍的RTT的开销。</li><li>为了减小时延，浏览器通常会建立多个并行的TCP连接同时请求多个对象。大量占用资源。</li></ul></li><li>HTTP/1.1采用<strong>持续连接方式</strong>。在该方式下，万维网服务器在发送响应后仍然保持这条连接，使同一个客户（浏览器）和该服务器可以继续在这条连接上传送后续的HTTP请求报文和响应报文。</li><li>这并不局限于传送同一个页面上引用的对象，而是只要这些文档都在同一个服务器上就行。</li><li>目前一些流行的浏览器的默认设置就是使用HTTP/1.1。</li><li>持续连接的两种工作方式：<ul><li><strong>非流水线方式</strong>：客户在收到前一个响应后才能发出下一个请求。这比非持续连接的两倍RTT的开销<strong>节省了建立TCP连接所需的一个RTT时间</strong>。但服务器在发送完一个对象后，其TCP连接就 处于空闲状态，浪费了服务器资源。</li><li><strong>流水线方式</strong>：客户在收到HTTP的响应报文之前就能够接着发送新的请求报文。一个接一个的请求报文到达服务器后，服务器就可连续发回响应报文。使用流水线方式时，<strong>客户访问所有的对象只需花费一个RTT时间</strong>，使TCP连接中的空闲时间减少，提高了下载文档效率。</li></ul></li><li>HTTP是面向文本的，其报文中的每一个字段都是一些ASCII码串，每个字段的长度都是不确定的。</li></ul><img src="/2024/06/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC%E5%85%AD%E7%AB%A0-%E5%BA%94%E7%94%A8%E5%B1%82/2.png" class="">]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计网</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络第五章 运输层</title>
    <link href="/2024/06/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC%E4%BA%94%E7%AB%A0-%E8%BF%90%E8%BE%93%E5%B1%82/"/>
    <url>/2024/06/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC%E4%BA%94%E7%AB%A0-%E8%BF%90%E8%BE%93%E5%B1%82/</url>
    
    <content type="html"><![CDATA[<h2 id="一-运输层概述"><a class="markdownIt-Anchor" href="#一-运输层概述"></a> 一、运输层概述</h2><h3 id="1-进程间的通信"><a class="markdownIt-Anchor" href="#1-进程间的通信"></a> 1、进程间的通信</h3><ul><li>在计算机网络中实际进行通信的真正实体：是<strong>位于通信两端主机中的进程</strong>。</li><li>如何为运行在不同主机上的<strong>应用进程提供直接的逻辑通信服务</strong>，就是运输层的主要任务。</li><li><strong>运输层协议又称为端到端协议</strong>（端到端的通信是应用进程之间的通信）。</li></ul><h3 id="2-运输层中的两个重要协议"><a class="markdownIt-Anchor" href="#2-运输层中的两个重要协议"></a> 2、运输层中的两个重要协议</h3><h4 id="tcp"><a class="markdownIt-Anchor" href="#tcp"></a> TCP</h4><ul><li><strong>传输控制协议</strong>（Transmission Control Protocol，TCP）为其上层提供的是<strong>面向连接的可靠的</strong>数据传输服务。</li><li>使用TCP通信的双方，在传送数据之前<strong>必须首先建立TCP连接</strong>（<strong>逻辑连接</strong>，而非物理连接）。数据<strong>传输结束后必须要释放TCP连接</strong>。</li><li>TCP为了实现可靠传输，就必须使用很多措施，例如TCP连接管理、确认机制、超时重传、流量控制以及拥塞控制等。</li><li>TCP的<strong>实现复杂</strong>，TCP报文段的<strong>首部比较大</strong>，<strong>占用处理机资源比较多</strong>。</li></ul><h4 id="udp"><a class="markdownIt-Anchor" href="#udp"></a> UDP</h4><ul><li><strong>用户数据报协议</strong>（User Datagram Protocol，UDP）为其上层提供的是<strong>无连接的不可靠的</strong>数据传输服务。</li><li>使用UDP通信的双方，在传送数据之前<strong>不需要建立连接</strong>。</li><li>UDP不需要实现可靠传输，因此<strong>不需要使用实现可靠传输的各种机制</strong>。</li><li>UDP的<strong>实现简单</strong>，UDP用户数据报的<strong>首部比较小</strong>。</li></ul><h3 id="3-运输层的端口"><a class="markdownIt-Anchor" href="#3-运输层的端口"></a> 3、运输层的端口</h3><ul><li>运行在计算机上的进程是使用<strong>进程标识符</strong>（Process Identification，PID）来标识的。</li><li>运行在应用层的各种应用进程不应当让计算机操作系统指派它的进程标识符，原因是：<ul><li>互联网上的计算机并不是使用统一的操作系统，而不同操作系统（Windows、Linux、MacOS）又使用不同格式的进程标识符。</li><li>为了使运行不同操作系统的计算机的应用进程之间能够基于网络进行通信，就<strong>必须使用统一的方法对TCP/IP体系的应用进程进行标识</strong>。</li></ul></li><li>TCP/IP体系结构的<strong>运输层使用协议端口号</strong>（Protocol Port Number）来标识和区分不同应用进程。<ul><li>进程的创建和撤销都是动态的，发送方几乎无法识别其他机器上的进程。</li><li>有时用户会改换接收报文的进程，这并不需要通知所有发送方。</li><li>往往需要利用目的主机提供的功能来识别终点，但并不需要知道实现这个功能的进程。</li></ul></li><li>端口号的长度为16比特，取值范围是0~65535。</li></ul><img src="/2024/06/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC%E4%BA%94%E7%AB%A0-%E8%BF%90%E8%BE%93%E5%B1%82/1.png" class=""><ul><li>两个不同的端口概念：<ul><li><strong>软件端口</strong>：在协议栈层间的抽象的<strong>协议端口</strong>。</li><li>硬件端口：路由器或交换机上的端口。</li></ul></li><li>硬件端口是不同硬件设备进行交互的接口，而<strong>软件端口是应用层的各种协议进程与运输实体进行层间交互的一种地址</strong>。</li></ul><h2 id="二-udp协议和tcp协议概述"><a class="markdownIt-Anchor" href="#二-udp协议和tcp协议概述"></a> 二、UDP协议和TCP协议概述</h2><ul><li><p>UDP支持单播、多播和广播；TCP仅支持单播。</p></li><li><p>UDP是面向应用报文的；TCP是面向字节流的。</p></li><li><p>UDP向上层提供无连接不可靠传输服务（适用于IP电话、视频会议等<strong>实时应用</strong>）；TCP向上层提供面向连接的可靠传输服务（适用于要求<strong>可靠传输的应用</strong>，例如<strong>文件传输</strong>）。</p></li><li><p>UDP用户数据报首部仅8字节；TCP报文段首部最小20字节，最大60字节。</p></li><li><p>UDP只在IP的数据报服务之上增加了很少一点的功能：</p><ul><li>复用和分用的功能，</li><li>差错检测的功能。</li></ul></li><li><p>虽然UDP用户数据报只能提供不可靠的交付，但UDP在某些方面有其特殊的优点。</p><ul><li>UDP是无连接的，<strong>发送数据之前不需要建立连接</strong>，减少了开销和发送数据之前的时延。</li><li>UDP使用尽最大努力交付，即不保证可靠交付，不需要维持复杂的连接状态表。</li><li>UDP是面向报文的，UDP对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界（<strong>UDP一次交付一个完整的报文</strong>）。</li><li>UDP没有拥塞控制，因此网络出现的拥塞不会使源主机的发送速率降低。这对某些实时应用是很重要的，<strong>适合多媒体通信的要求</strong>。端口号的长度为16比特，取值范围是0~65535。</li><li>UDP支持一对一、一对多、多对一和多对多的交互通信。</li><li>UDP的首部开销小，<strong>只有8个字节</strong>，比TCP的20个字节的首部要短。</li></ul></li><li><p>应用程序必须选择合适大小的报文。</p><ul><li>若报文太长，UDP把它交给IP层后，IP层在传送时可能要进行<strong>分片</strong>，这会降低IP层的效率。</li><li>若报文太短，UDP把它交给IP层后，IP数据报的<strong>首部的相对长度太大</strong>，这也降低了IP层的效率。</li></ul></li><li><p>UDP用户数据报有两个字段：数据字段和首部字段，首部字段只有 8 个字节。</p></li><li><p>在计算检验和时，<strong>临时</strong>把“伪首部”和UDP用户数据报连接在一起。<strong>伪首部仅是为了计算检验和</strong>。</p></li></ul><img src="/2024/06/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC%E4%BA%94%E7%AB%A0-%E8%BF%90%E8%BE%93%E5%B1%82/2.png" class=""><h3 id="三-tcp报文段的首部格式"><a class="markdownIt-Anchor" href="#三-tcp报文段的首部格式"></a> 三、TCP报文段的首部格式</h3><h3 id="1-传输控制协议tcp"><a class="markdownIt-Anchor" href="#1-传输控制协议tcp"></a> 1、传输控制协议TCP</h3><ul><li>TCP是面向连接的运输层协议：建立/释放逻辑连接（虚连接）。</li><li>每一条TCP连接只能有两个端点 (endpoint)，每一条TCP连接只能是点对点的（一对一）。</li><li>TCP提供可靠交付的服务：<strong>无差错、不丢失、按顺序、不重复</strong>。</li><li>TCP提供全双工通信：TCP连接的两端都设有发送缓存和接收缓存。</li><li>面向字节流。<ul><li>“流”（stream）指的是流入或流出进程的<strong>字节序列</strong>。</li><li>虽然应用程序和TCP的交互是一次一个数据块，但TCP把应用程序交下来的数据看成仅仅是一连串无结构的字节流。</li><li>TCP不保证接收方应用程序所收到的数据块和发送方所发出的数据块具有对应大小的关系。</li><li>但接收方应用程序收到的字节流必须和发送方应用程序发出的字节流完全一样。</li></ul></li><li>TCP根据对方窗口值和网络拥塞程度来决定一个报文段应包含多少个字节；UDP的报文长度是应用进程给出的。</li><li>TCP可把太长的数据块划分短一些再传送，也可等待积累有足够多的字节后再构成报文段发送出去。</li></ul><h3 id="2-tcp报文段的首部格式"><a class="markdownIt-Anchor" href="#2-tcp报文段的首部格式"></a> 2、TCP报文段的首部格式</h3><ul><li>TCP是面向字节流的，但TCP传送的数据单元却是报文段。</li><li>TCP的全部功能需要依靠其首部中的各字段来实现。</li><li>TCP报文段首部前20个字节是固定的，后面有4n字节是根据需要而增加的选项。<strong>TCP首部的最小长度是20字节</strong>。</li></ul><img src="/2024/06/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC%E4%BA%94%E7%AB%A0-%E8%BF%90%E8%BE%93%E5%B1%82/3.png" class=""><ul><li><p>序号：占32比特，取值范围0~2<sup>32</sup>-1。当序号增加到最后一个时，下一个序号又回到0。<strong>用来指出本TCP报文段数据载荷的第一个字节的序号</strong>。</p></li><li><p>确认号：占32比特，取值范围0~2<sup>32</sup>-1。当确认号增加到最后一个时，下一个确认号又回到0。<strong>用来指出期望收到对方下一个TCP报文段的数据载荷的第一个字节的序号，同时也是对之前收到的所有数据的确认</strong>。</p></li><li><p>确认标志位ACK：<strong>只有当ACK取值为1时，确认号字段才有效</strong>。ACK取值为0时，确认号字段无效。TCP规定：<strong>在TCP连接建立后，所有传送的TCP报文段都必须把ACK置1</strong>。</p></li><li><p>数据偏移：占4比特，该字段的取值<strong>以4字节为单位</strong>。指出TCP报文段的<strong>数据载荷部分</strong>的起始处距离TCP报文段的起始处有多远，<strong>这实际上指出了TCP报文段的首部长度</strong>。</p></li><li><p>保留：占6比特；保留为今后使用；目前应置为0。</p></li><li><p>窗口：占16比特，该字段的取值<strong>以字节为单位</strong>；指出发送本报文段的一方的<strong>接收窗口的大小（非发送窗口）</strong>，即接收缓存的可用空间大小（允许对方发送的数据量），用来表征<strong>接收能力</strong>；在计算机网络中，经常<strong>用接收方接收能力的大小来控制发送方的数据发送量</strong>，这就是所谓的<strong>流量控制</strong>。</p></li><li><p>检验和：占16比特；<strong>用来检查整个TCP报文段在传输过程中是否出现了误码</strong>。</p></li><li><p>发送方检验和计算方法</p><ul><li>将TCP首部中检验和字段的值置为0。</li><li>将伪首部、TCP首部以及数据载荷这三部分<strong>划分成若干个2字节的单元</strong>。若伪首部、TCP首部以及数据载荷这三部分的总长度不是偶数个字节，则在最后添加1个“全0”字节。</li><li>对划分出的全部2字节的单元进行<strong>反码算数运算求和</strong>，并将求和结果<strong>取反</strong>。</li><li>将步骤③得到的结果写入TCP首部中的检验和字段。</li></ul></li><li><p>同步标志位SYN</p><ul><li>同步标志位用于TCP“三报文握手”<strong>建立连接</strong>。</li><li>当<strong>SYN=1且ACK=0</strong>时，表明这是一个<strong>TCP连接请求报文段</strong>。</li><li>对方若<strong>同意建立连接</strong>，则应在<strong>响应</strong>的TCP报文段的首部中使<strong>SYN=1且ACK=1</strong>。、</li><li>SYN=1的TCP报文段<strong>要么是一个连接请求报文段，要么是一个连接响应报文段</strong>。</li></ul></li><li><p>终止标志位FIN</p><ul><li>终止标志位用于TCP“四报文挥手”<strong>释放连接</strong>。</li><li>当<strong>FIN=1</strong>时，表明此TCP报文段的发送方已经将全部数据发送完毕，现在<strong>要求释放TCP连接</strong>。</li></ul></li><li><p>复位标志位RST</p><ul><li>复位标志位用于复位TCP连接。</li><li>当RST=1时，表明TCP连接中<strong>出现严重差错</strong>，必须<strong>释放连接</strong>，然后再<strong>重新建立连接</strong>。</li><li><strong>RST置1还用来拒绝一个非法的TCP报文段或拒绝打开一个TCP连接</strong>。</li></ul></li><li><p>推送标志位PSH</p><ul><li>发送方把PSH置1，并立即创建一个TCP报文段发送出去，而不需要积累到足够多的数据再发送。</li><li>接收方收到PSH=1的TCP报文段，就尽快地交付给应用进程，而不再等到接收到足够多的数据才交付。</li></ul></li><li><p>紧急指针</p><ul><li>占16比特，以字节为单位，用来指明紧急数据的长度。</li><li>当<strong>发送方有紧急数据</strong>时，可将紧急数据“<strong>插队</strong>”到发送缓存的最前面，并立刻封装到一个TCP报文段中进行发送。<strong>紧急指针会指出本报文段数据载荷部分包含了多长的紧急数据</strong>，紧急数据之后是普通数据。</li><li><strong>当接收方收到URG=1的TCP报文段</strong>，会按照紧急指针字段的值从报文段数据载荷中取出紧急数据并直接上交应用进程，而<strong>不必在接收缓存中排队</strong>。</li></ul></li><li><p>紧急标志位URG</p><ul><li>当URG=1时，紧急指针字段有效。</li><li>当URG=0时，紧急指针字段无效。</li></ul></li><li><p>选项（长度可变，最大40字节）</p><ul><li>最大报文段长度MSS选项：指出TCP报文段数据载荷部分的最大长度，而不是整个TCP报文段的长度。</li><li>窗口扩大选项：用来扩大窗口，提高吞吐率。</li><li>时间戳选项：<ul><li>用于计算往返时间RTT</li><li>用于处理序号超范围的情况，又称为防止序号绕回PAWS（protect against wrapped sequence numbers）。</li><li>选择确认选项：用来实现选择确认功能。</li></ul></li></ul></li><li><p>填充：若选项字段的长度加上20字节固定首部的长度不能被4字节整除时，需要填充相应数量的比特0，以确保首部长度能被4字节整除。</p></li></ul><h2 id="四-tcp的连接管理"><a class="markdownIt-Anchor" href="#四-tcp的连接管理"></a> 四、TCP的连接管理</h2><h3 id="1-tcp的连接"><a class="markdownIt-Anchor" href="#1-tcp的连接"></a> 1、TCP的连接</h3><ul><li>TCP是面向连接的协议，它基于<strong>运输连接</strong>来传送TCP报文段。</li><li>TCP把连接作为最基本的抽象。<ul><li>每一条TCP连接有两个端点。</li><li>TCP连接的端点不是主机，不是主机的IP地址，不是应用进程，不是运输层的协议端口。</li><li>TCP连接的端点叫做<strong>套接字</strong>（socket）或插口。</li><li>端口号拼接（contatenated with）IP地址即构成了套接字。套接字 socket = (IP地址 : 端口号)</li><li>每一条TCP连接唯一地被通信两端的两个端点（即两个套接字）所确定。<br />TCP 连接 := {socket1, socket2} = {(IP1: port1)，(IP2: port2)}</li></ul></li><li>TCP连接就是由协议软件所提供的一种抽象。</li><li><strong>同一个IP地址可以有多个不同的TCP连接</strong>。</li><li><strong>同一个端口号也可以出现在多个不同的TCP连接中</strong>。</li><li>TCP运输连接有以下三个阶段：<ul><li>通过“三报文握手”来建立TCP连接。</li><li>基于已建立的TCP连接进行可靠的数据传输。</li><li>在数据传输结束后，还要通过“四报文挥手”来释放TCP连接。</li></ul></li></ul><h3 id="2-三报文握手建立tcp连接"><a class="markdownIt-Anchor" href="#2-三报文握手建立tcp连接"></a> 2、三报文握手”建立TCP连接</h3><ul><li><p>“三报文握手”建立TCP连接的目的在于解决以下三个主要问题：</p><ul><li>使TCP双方能够确知对方的存在。</li><li>使TCP双方能够协商一些参数（例如最大报文段长度、最大窗口大小、时间戳选项等）。</li><li>使TCP双方能够对运输实体资源（缓存大小、各状态变量、连接表中的项目等）进行分配和初始化。</li></ul></li><li><p>TCP连接的建立采用客户服务器方式。</p><ul><li>主动发起连接建立的应用进程叫做客户（client）。</li><li>被动等待连接建立的应用进程叫做服务器（server）。</li></ul></li><li><p><strong>TCP连接请求报文段</strong>和<strong>TCP连接请求确认报文段</strong>首部中的同步标志位SYN的值必须设置为1。</p></li><li><p>序号seq字段被设置了一个初始值x，作为TCP客户进程所选择的初始序号。</p><ul><li>TCP规定同步标志位SYN被设置为1的报文段（例如TCP连接请求报文段和TCP连接请求确认报文段）<strong>不能携带数据，但要消耗掉一个序号</strong>。</li><li>按上述规定，TCP连接请求报文段不能携带数据（即没有数据载荷），但是会消 耗掉序号x。</li><li>因此，TCP客户进程下一次发送的TCP报文段的数据载荷第一个字节的序号为x+1。</li></ul></li><li><p>TCP连接请求确认报文段首部中的同步标志位SYN和确认标志位ACK 的值都设置为1。</p></li><li><p>序号seq字段被设置了一个初始值y，作为TCP服务器进程所选择的初始序号。</p></li><li><p>确认号ack字段的值被设置为x+1，这是对TCP客户进程所选择的初始序号x的确认。</p></li><li><p>确认标志位ACK的值被设置为1，这是一个<strong>普通的TCP确认报文段</strong>。</p></li><li><p>因为TCP客户进程之前发送的TCP连接请求报文段的序号为x，该报文段虽然不能携 带数据，但要消耗掉一个序号。因此TCP客户进程发送的第二个报文段的序号为x+1。</p><ul><li>TCP规定普通的TCP确认报文段可以携带数据，但如果不携带数据，则不消耗序号。如果该报文段不携带数据，则TCP客户进程要发送的下一个数据报文段的序号仍为x+1。</li></ul></li><li><p>确认号ack字段的值被设置为y+1，这是对TCP服务器进程所选择的初始序号y的确认。</p></li></ul><img src="/2024/06/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC%E4%BA%94%E7%AB%A0-%E8%BF%90%E8%BE%93%E5%B1%82/4.png" class=""><ul><li>使用三报文握手而不是两报文的原因：</li></ul><img src="/2024/06/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC%E4%BA%94%E7%AB%A0-%E8%BF%90%E8%BE%93%E5%B1%82/5.png" class=""><h3 id="3-四报文挥手释放tcp连接"><a class="markdownIt-Anchor" href="#3-四报文挥手释放tcp连接"></a> 3、“四报文挥手”释放TCP连接</h3><ul><li>TCP连接释放报文段首部中的终止标志位FIN和确认标志位ACK的值都被设置为1。表明这是一个<strong>TCP连接释放报文段</strong>，同时也对之前收到的TCP报文段进行确认。</li><li>序号seq字段的值设置为u，它等于TCP客户进程之前已经传送过的数据的最后一个字节的序号加1。</li><li><strong>TCP规定终止标志位FIN等于1的TCP报文段即使不携带数据，也要消耗掉一个序号</strong>。</li><li>确认号ack字段的值设置为v，它等于TCP客户进程之前已收到的数据的最后一个字节的序号加1。</li><li>确认标志位ACK的值被设置为1，表明这是一个TCP普通确认报文段。</li><li>序号seq字段的值设置为v，它等于TCP服务器进程之前已传送过的数据的最后一个字节的序号加1。这也与之前收到的TCP连接释放报文段中的确认号v匹配。</li><li>确认号ack字段的值设置为u+1，这是对TCP连接释放报文段的确认。</li><li>从TCP客户进程到TCP服务器进程这个方向的连接就释放了。此时的TCP连接属于<strong>半关闭状态</strong>。</li><li>TCP客户进程已经没有数据要发送了。但TCP服务器进程如果还有数据要发送，TCP客户进程仍要接收，也就是从TCP服务器进程到TCP客户进程这个方向的连接并未关闭。</li><li>TCP连接释放报文段首部中的终止标志位FIN和确认标志位ACK的值都被设置为1。表明这是一个TCP连接释放报文段，同时也对之前收到的TCP报文段进行确认。</li><li>序号seq字段的值假定被设置为w，这是因为在半关闭状态下TCP服务器进程可能又发送了一些数据。</li><li>确认号ack字段的值被设置为u+1，这是对之前收到的TCP连接释放报文段的<strong>重复确认</strong>。</li><li>确认标志位ACK的值设置为1，表明这是一个TCP普通确认报文段。</li><li>序号seq字段的值设置为u+1，这是因为TCP客户进程之前发送 的TCP连接释放报文段虽然不携带数据，但要消耗掉一个序号。</li><li>确认号ack字段的值设置为w+1，这是对所收到的TCP连接释放 报文段的确认。</li><li>MSL是<strong>最长报文段寿命</strong>（Maximum Segment Lifetime）的英文缩写词， [RFC793]建议为2分钟。也就是说，TCP客户进程进入时间等待（TIMEWAIT）状态后，还要经过4分钟才能进入关闭（CLOSED）状态。</li><li>处于时间等待（TIME-WAIT）状态后要经过2MSL时长，可以<strong>确保TCP服务器进程能够收到最后一个TCP确认报文段而进入关闭（CLOSED）状态</strong>。</li><li>另外，TCP客户进程在发送完最后一个TCP确认报文段后，再经过2MSL时长，<strong>就可以使本次连接持续时间内所产生的的所有报文段都从网络中消失</strong>。这样就可以<strong>使下一个新的TCP连接中不会出现旧连接中的报文段</strong>。</li></ul><img src="/2024/06/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC%E4%BA%94%E7%AB%A0-%E8%BF%90%E8%BE%93%E5%B1%82/6.png" class=""><ul><li>TCP保活计时器的作用：若一连发送10个探测报文段后仍无TCP客户进程的响应，TCP服务器进程就认为TCP客户进程所在主机出了故障，于是就关闭这个连接。</li></ul><h3 id="五-tcp的流量控制"><a class="markdownIt-Anchor" href="#五-tcp的流量控制"></a> 五、TCP的流量控制</h3><h3 id="1-tcp的流量控制"><a class="markdownIt-Anchor" href="#1-tcp的流量控制"></a> 1、TCP的流量控制</h3><ul><li><p>一般说来，我们总是希望数据传输得更快一些。但如果发送方把数据发送得过快，接收方就可能来不及接收，这就会造成数据的丢失。</p></li><li><p>流量控制（flow control）是让发送方的发送速率不要太快，既让接收方来得及接收，也不要使网络发生拥塞。</p></li><li><p>利用滑动窗口机制可以很方便地在TCP连接上实现流量控制。</p></li><li><p>为了打破由于非零窗口通知报 文段丢失而引起的双方互相等待的 死锁局面，TCP为每一个连接都设有 一个持续计时器。</p></li><li><p>只要TCP连接的一方收到对方的 零窗口通知，就启动持续计时器。</p></li><li><p>当持续计时器超时时，就发送一 个零窗口探测报文段，仅携带1字节的数据。</p></li><li><p>对方在确认这个零窗口探测报文段时，给出自己现在的接收窗口 值。</p></li><li><p>如果接收窗口值仍然是0，那么收到这个报文段的一方就重新启动 持续计时器。</p></li><li><p>如果接收窗口值不是0，那么死锁的局面就可以被打破了。</p></li></ul><h2 id="六-tcp的拥塞控制"><a class="markdownIt-Anchor" href="#六-tcp的拥塞控制"></a> 六、TCP的拥塞控制</h2><h3 id="1-拥塞控制的基本概念"><a class="markdownIt-Anchor" href="#1-拥塞控制的基本概念"></a> 1、拥塞控制的基本概念</h3><ul><li>在某段时间，若对网络中某一资源（计算机网络中的链路带宽、交换节点中的缓存和处理机等都是网络的资源）的需求超过了该资源所能提供的可用部分，网络性能就要变坏，这种情况就叫作拥塞（congestion）。</li><li>若网络中有许多资源同时产生拥塞，网络的性能就要明显变坏。</li><li>若出现拥塞而不进行控制，整个网络的吞吐量将随输入负荷的增大而下降。</li><li>增加资源能解决拥塞吗？不能。</li><li>这是因为网络拥塞是一个非常复杂的问题。简单地采用上述做法，在许多情况下，不但不能解决拥塞问题， 而且还可能使网络的性能更坏。</li><li>网络拥塞往往是由许多因素引起的，例如：<ul><li>增大缓存，但未提高输出链路的容量和处理机的速度，排队等待时间会大大增加，引起大量超时重传。</li><li>提高处理机处理的速率会会将瓶颈转移到其他地方。</li></ul></li><li>拥塞常常趋于恶化，例如：<ul><li>若一个路由器没有足够的缓存空间，它就会丢弃一些新到的分组。当分组被丢弃时，源点就会重传这一分组，甚至可能还要重传多次。这样会引起更多的分组流入网络，并被网络中的路由器丢弃。</li><li><strong>可见拥塞引起的重传并不会缓解网络的拥塞，反而会加剧网络的拥塞</strong>。</li></ul></li><li>实践证明，拥塞控制是很难设计的，因为它是一个动态的（而不是静态的）问题。</li><li>分组的丢失是网络发生拥塞的征兆而不是原因。</li><li>在许多情况下，甚至正是拥塞控制本身成为引起网络性能恶化甚至发生死锁的原因。这点应特别引起重视。</li></ul><h4 id="流量控制与拥塞控制的区别"><a class="markdownIt-Anchor" href="#流量控制与拥塞控制的区别"></a> 流量控制与拥塞控制的区别</h4><ul><li>流量控制<ul><li>点对点控制：接收端控制发送端</li><li>以接收方的接收能力来控制发送方（源点）的发送速率，只与特定的点对点通信的发送方和接收方之间的流量有关。</li></ul></li><li>拥塞控制<ul><li>全局性的控制问题</li><li><strong>源点</strong>根据各方面因素，按<strong>拥塞控制算法自行控制发送速率</strong>，是一个全局性的问题，涉及网络中所有的主机、路由器等。</li></ul></li></ul><h3 id="2-拥塞控制的基本原理"><a class="markdownIt-Anchor" href="#2-拥塞控制的基本原理"></a> 2、拥塞控制的基本原理</h3><ul><li>开环控制<ul><li>试图用良好的设计来解决问题。</li><li>从一开始就保证问题不会发生。</li><li>一旦系统启动并运行起来，就不需要中途修正。</li></ul></li><li>闭环控制<ul><li>基于反馈的控制方法，包括以下三个部分：</li><li>监测网络拥塞在何时、何地发生。</li><li>把拥塞发生的相关信息传送到可以采取行动的地方。</li><li>调整网络的运行以解决拥塞问题。</li></ul></li><li>当网络的流量特征不能准确描述或者当网 络不提供资源预留时，适合使用闭环控制。 互联网采用的就是闭环控制方法。</li><li>根据拥塞信息的反馈形式，可将闭环拥塞控制算法分为<ul><li>显式反馈算法：<strong>从拥塞节点（即路由器）向源点</strong>提供关于网络中拥塞状态的显式反馈信息。</li><li>隐式反馈算法：源点自身通过对网络行为的观察（例如超 时重传或往返时间RTT）来推断网络是否发生了拥塞。<strong>TCP采用的就是隐式反馈算法</strong>。</li></ul></li></ul><h3 id="3-tcp拥塞控制的方法"><a class="markdownIt-Anchor" href="#3-tcp拥塞控制的方法"></a> 3、TCP拥塞控制的方法</h3><ul><li>TCP采用基于窗口的方法进行拥塞控制，属于闭环控制方法。<ul><li>TCP发送方维持一个拥塞窗口cwnd</li><li>拥塞窗口的大小取决于网络的拥塞程度，并且动态地在变化。</li><li>发送端利用拥塞窗口根据网络的拥塞情况调整发送的数据量。</li><li>真正的发送窗口值为：swnd=min(rwnd, cwnd)</li></ul></li><li>网络没出现拥塞：拥塞窗口就可以再增大一些，以便把更多的分组发送出去，这样就可以提高网络的利用率。</li><li>网络（可能）出现拥塞：必须把拥塞窗口减小一些，以减少网络中的分组数，以便缓解网络出现的拥塞。</li><li>拥塞的判断：<ul><li>重传定时器超时：出现了<strong>超时</strong>，就可以猜想网络可能出现了拥塞（因传输出差错而丢弃分组远小于1%）。</li><li>收到三个重复的ACK：报文段在网络中出现了丢失，预示可能会出现拥塞，可尽快采取措施，避免拥塞。</li></ul></li><li>为了讨论拥塞控制算法的基本原理，假定如下条件<ul><li>数据是单方向传送的，而另一个方向只传送确认。</li><li>接收方总是有足够大的接收缓存空间，因而发送方的发送窗口的大小仅由网络的拥塞程度来决定，也就是<strong>不考虑接收方对发送方的流量控制</strong>。</li><li>以TCP最大报文段MSS（即TCP报文段的数据载荷部分）的个数作为讨论问题的单位，而不是以字节为单位（尽管TCP是面向字节流的）。</li></ul></li></ul><img src="/2024/06/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC%E4%BA%94%E7%AB%A0-%E8%BF%90%E8%BE%93%E5%B1%82/7.png" class=""><img src="/2024/06/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC%E4%BA%94%E7%AB%A0-%E8%BF%90%E8%BE%93%E5%B1%82/8.png" class=""><ul><li><p>“慢开始”是指一开始向网络注入的报文段少，而并不是指拥塞窗口cwnd的值增长速度慢。</p></li><li><p>“拥塞避免”也并非指完全能够避免拥塞，而是指在拥塞避免阶段将cwnd值控制为按线性规律增长，使网络比较不容易出现拥塞。</p></li><li><p>采用快重传算法可以让发送方尽早知道发生了个别TCP报文段的丢失。</p></li><li><p>“快重传”是指使发送方尽快（尽早）进行重传，而不是等重传计时器超时再重传。</p><ul><li>接收方不再等待自己发送数据时才进行捎带确认，而是要立即发送确认，即使收到了失序的报文段也要立即发出对已收到的报文段的重复确认。</li><li>发送方一旦收到3个连续的重复确认，就将相应的报文段立即重传，而不是等该报文段的重传计时器超时再重传。</li></ul></li><li><p>与快重传算法配合使用的是快恢复算法，发送方一旦收到3个重复确认，就知道现在只是丢失了个别的报文段，于是不启动慢开始算法，而是执行快恢复算法。</p></li><li><p>发送方将慢开始门限ssthresh的值和拥塞窗口cwnd的值都调整为当前cwnd值的一半，并执行拥塞避免算法。</p></li><li><p>有的快恢复实现是把快恢复开始时的cwnd值再增大一些，即cwnd=新ssthresh+3。</p><ul><li>既然发送方收到了3个重复的确认，就表明有3个数据报文段已经离开了网络。</li><li>这3个报文段不再消耗网络资源而是停留在接收方的接收缓存中。</li><li>可见现在网络中不是堆积了报文段而是减少了3个报文段，因此可以适当把cwnd值增大一些。</li></ul></li></ul><img src="/2024/06/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC%E4%BA%94%E7%AB%A0-%E8%BF%90%E8%BE%93%E5%B1%82/9.png" class=""><img src="/2024/06/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC%E4%BA%94%E7%AB%A0-%E8%BF%90%E8%BE%93%E5%B1%82/10.png" class=""><ul><li>可以看出，在<strong>拥塞避免阶段</strong>，拥塞窗口是按照线性规律增大的。常称为**“加法增大”**(AI， Additive Increase) 。</li><li>出现超时或3个重复的确认时， 就要把门限值设置为当前拥塞窗口值的一半，并大大减小拥塞窗口的数值。称为“<strong>乘法减小</strong>”(MD ， Multiplicative Decrease)。</li><li>就是所谓的<strong>AIMD算法</strong>。</li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计网</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络第四章 网络层</title>
    <link href="/2024/06/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E7%BD%91%E7%BB%9C%E5%B1%82/"/>
    <url>/2024/06/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E7%BD%91%E7%BB%9C%E5%B1%82/</url>
    
    <content type="html"><![CDATA[<h2 id="一-网络层概述"><a class="markdownIt-Anchor" href="#一-网络层概述"></a> 一、网络层概述</h2><h3 id="1-网络层提供的两种服务"><a class="markdownIt-Anchor" href="#1-网络层提供的两种服务"></a> 1、网络层提供的两种服务</h3><h4 id="面向连接的虚电路服务"><a class="markdownIt-Anchor" href="#面向连接的虚电路服务"></a> 面向连接的虚电路服务</h4><ul><li>核心思想：可靠通信应由网络自身来保证。</li><li>必须首先建立网络层连接：<strong>虚电路</strong>（Virtual Circuit，VC），以保证通信双方所需的一切网络资源。<ul><li>虚电路表示这是一条逻辑上的连接，分组沿着这条逻辑连接按照存储转发方式传送，而不是真正建立了一条物理连接。</li><li>而采用电路交换，是先建立一条真正的物理连接。因此，分组交换的虚连接与电路交换的连接只是类似，但并不一样。</li><li>分组的首部仅在连接建立阶段使用完整的目的主机地址，之后每个分组的首部只需要携带一条虚电路编号即可。</li></ul></li><li>通信双方沿着已建立的虚电路发送分组。</li><li>通信结束后，需要<strong>释放</strong>之前所建立的虚电路。</li><li>这种通信方式再使用可靠传输的网络协议，就可使所发送的分组最终正确（无差错、按顺序、不丢失、不重复）到达接收方。</li><li>因特网的先驱者并没有采用这种设计思想，而是采用了无连接的数据报服务。</li></ul><h4 id="无连接的数据报服务"><a class="markdownIt-Anchor" href="#无连接的数据报服务"></a> 无连接的数据报服务</h4><ul><li><p>核心思想：可靠通信应由用户主机（端系统）来保证。</p></li><li><p>不需要建立网络层连接，尽最大努力交付。</p></li><li><p>每个分组可走不同的路径，每个分组的首部都必须携带目的主机的完整地址。</p></li><li><p>通信结束后，没有需要释放的连接。</p></li><li><p>将复杂的网络处理功能置于因特网的边缘（即用户主机和其内部的运输层），将相对简单的尽最大努力（即不可靠）的分组交付功能置于因特网核心。</p></li></ul><h3 id="2-网络层的两个层面"><a class="markdownIt-Anchor" href="#2-网络层的两个层面"></a> 2、网络层的两个层面</h3><ul><li>网络层的主要任务就是将分组从源主机经过多个网络和多段链路传输到目的主机</li><li>可以将该任务划分为<strong>分组转发</strong>和<strong>路由选择</strong>两种重要的功能。</li><li>可以把网络层抽象地划分为<strong>数据层面（转发层面）和控制层面</strong>。</li></ul><img src="/2024/06/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E7%BD%91%E7%BB%9C%E5%B1%82/1.png" class=""><h2 id="二-网际协议ip"><a class="markdownIt-Anchor" href="#二-网际协议ip"></a> 二、网际协议IP</h2><h3 id="1-虚拟互连网络"><a class="markdownIt-Anchor" href="#1-虚拟互连网络"></a> 1、虚拟互连网络</h3><ul><li>将网络互相连接起来要使用一些中间设备。中间设备又称为中间系统或中继 (relay)系统。</li><li>有以下五种不同的中间设备：<ul><li>物理层中继系统：转发器 (repeater)、集线器（hub）</li><li>数据链路层中继系统：网桥 (bridge)、交换机（switch）</li><li>网络层中继系统：路由器 (router)<ul><li>网桥和路由器的混合物：桥路器 (brouter)</li></ul></li><li>网络层以上的中继系统：网关 (gateway)</li></ul></li><li>当中继系统是转发器、集线器或网桥时，并不称之为网络互连，因为这仅仅是把一个网络扩大了，而这仍然是一个网络。</li><li>网络互连：指使用<strong>路由器</strong>进行网络互连和路由选择。</li><li>虚拟互连网络：逻辑互连网络。<ul><li>指互连起来的各种物理网络的异构性本来是客观存在的，但是我们<strong>利用IP协议就可以使这些性能各异的网络在网络层上看起来好像是一个统一的网络</strong>。</li><li>使用 IP 协议的虚拟互连网络可简称为 IP 网。</li><li>当互联网上的主机进行通信时，就好像在一个网络上通信一样，而看不见互连的各具体网络异构细节。</li><li>如果在这种覆盖全球的 IP 网的上层（运输层）使用 TCP 协议，那么就是现在的互联网(Internet)。</li></ul></li><li>如果我们只从网络层考虑问题，那么 IP 数据报就可以想象是在网络层中传送。<ul><li>分组在传送过程中每一次转发都称为一“跳（hop）”。</li><li>每一跳两端的两个节点一定直接连在同一个网络上。</li></ul></li></ul><h3 id="2-ip地址ipv4"><a class="markdownIt-Anchor" href="#2-ip地址ipv4"></a> 2、IP地址（IPv4）</h3><p>IPv4地址是给互联网上每一个主机/路由器的<strong>每一个接口</strong>分配的一个在全世界范围内唯一的32比特的标识符。</p><h4 id="ip地址的表示方法"><a class="markdownIt-Anchor" href="#ip地址的表示方法"></a> IP地址的表示方法</h4><ul><li>由于IPv4地址由32比特构成，IPv4地址采用点分十进制表示方法以提高可读性。</li></ul><img src="/2024/06/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E7%BD%91%E7%BB%9C%E5%B1%82/2.png" class=""><h4 id="分类编址方法"><a class="markdownIt-Anchor" href="#分类编址方法"></a> 分类编址方法</h4><ul><li>将 IP 地址划分为若干个固定类。每一类地址都由两个固定长度的字段组成，其中一个字段是网络号 net-id，它标志主机（或路由器）所连接到的网络，而另一个字段则是主机号 host-id，它标志该主机（或路由器）。</li><li>主机号在它所连接的网络中（前面的网络号所指明的网络）必须是唯一的。</li><li>一个 IP 地址在整个互联网范围内是唯一的。</li></ul><img src="/2024/06/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E7%BD%91%E7%BB%9C%E5%B1%82/3.png" class=""><img src="/2024/06/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E7%BD%91%E7%BB%9C%E5%B1%82/4.png" class=""><ul><li><p>A类、B类和C类地址都是单播地址，只有单播地址可以分配给网络中的主机（或路由器）的各接口。</p></li><li><p>主机号为“全 0”的地址是<strong>网络地址</strong>，不能分配给主机（或路由器）的各接口。</p></li><li><p>主机号为“全 1”的地址是<strong>广播地址</strong>，不能分配给主机（或路由器）的各接口。</p></li><li><p>最小网络号为0，表示<strong>本网络</strong>，不能指派。</p></li><li><p>最大网络号为127，作为本地<strong>环回测试地址</strong>，不能指派。</p></li><li><p><strong>可指派</strong>的A类<strong>网络数量</strong>为 2<sup>(8-1)</sup>-2=126（减2是去掉最小网络号0和最大网络号127）</p></li><li><p>每个A类网络中<strong>可分配</strong>的<strong>地址数量</strong>为 2<sup>24</sup>-2=16777214（减2是去掉主机号为全0的网络地址和全1的广播地址）</p></li></ul><img src="/2024/06/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E7%BD%91%E7%BB%9C%E5%B1%82/5.png" class=""><h4 id="划分子网编址方法"><a class="markdownIt-Anchor" href="#划分子网编址方法"></a> 划分子网编址方法</h4><ul><li>随着更多的中小网络加入互联网，IPv4分类编址方法不够灵活、容易造成大量IPv4地址资源浪费。</li><li>划分子网编址方法对分类编址方法进行改进。在IP地址的主机号中，插入一个子网号，把两级的IP地址变为三级的IP地址。</li><li>子网掩码可以表明分类IPv4地址的主机号部分被借用了几个比特作为子网号。</li><li>与IPv4地址类似，子网掩码也是由32比特构成的。<ul><li>用左起多个连续的比特1对应IPv4地址中的网络号和子网号；</li><li>之后的多个连续的比特0对应IPv4地址中的主机号。</li></ul></li><li>将划分子网的IPv4地址与相应的子网掩码进行逐比特的逻辑与运算，可得到该IPv4地址所在子网的<strong>网络地址</strong>。</li><li>默认子网掩码：是指在未划分子网的情况下使用的子网掩码。</li></ul><h4 id="无分类编址方法-cidr"><a class="markdownIt-Anchor" href="#无分类编址方法-cidr"></a> 无分类编址方法 CIDR</h4><ul><li><p>无分类编址方法使用的地址掩码与划分子网使用的子网掩码类似，由32比特构成。</p><ul><li>左起多个连续的比特1对应IPv4地址中的网络前缀；</li><li>之后的多个连续的比特0对应IPv4地址中的主机号。</li></ul></li><li><p>斜线记法（CIDR记法）：可以不明确给出配套的地址掩码的点分十进制形式，而是在无分类编址的IPv4地址后面加上斜线“/” ，在斜线之后写上<strong>网络前缀所占的比特数量</strong>（也就是地址掩码中左起连续比特1的数量）</p></li><li><p>实际上，无分类域间路由选择CIDR是将网络前缀都相同的、连续的多个无分类IPv4地址，组成一个CIDR地址块（网络前缀都相同的所有连续的IP地址）。</p></li><li><p>使用无分类编址方法，可以根据需要，分配适当大小的CIDR地址块，更加有效地分配IPv4的地址空间。</p></li><li><p>划分子网 (subnetting)：网络前缀越短，地址块所包含的地址数就越多。在三级结构IP地址中，划分子网使网络前缀变长。</p></li><li><p>构造超网 (supernetting)：前缀不超过 23 位的 CIDR 地址块含多个 C 类地址，这些C类地址合起来构成超网。</p><ul><li>构成超网也称为路由聚合。</li><li>一个 CIDR 地址块可以表示很多地址，这种地址的聚合常称为路由聚合，它使得路由表中的一个项目可以表示很多个（例如上千个）原来传统分类地址的路由。</li><li>路由聚合有利于减少路由器之间的路由选择信息的交换，从而提高了整个互联网的性能。</li></ul></li><li><p>CIDR 地址块中的地址数一定是 2 的整数次幂。</p></li><li><p>CIDR 可以更加有效地分配 IPv4 的地址空间，可根据客户的需要分配适当大小的CIDR地址块。</p></li></ul><h4 id="ip地址的特点"><a class="markdownIt-Anchor" href="#ip地址的特点"></a> IP地址的特点</h4><ul><li><p>IP 地址是一种<strong>分等级的地址结构</strong>，好处是：</p></li><li><p>第一，IP 地址管理机构在分配 IP 地址时只分配网络号，而剩下的主机号则由得到该网络号的单位自行分配，方便了 IP 地址的管理。</p></li><li><p>第二，路由器<strong>仅根据目的主机所连接的网络号</strong>来转发分组（而不考虑目的主机号），这样就可以使路由表中的项目数大幅度减少，从而减小了路由表所占的存储空间。</p></li><li><p>实际上 IP 地址是标志一个主机（或路由器）和一条链路的<strong>接口</strong>。</p><ul><li>当一个主机同时连接到两个网络上时，该主机就必须同时具有两个相应的IP 地址，其网络号net-id必须是不同的，这种主机称为多归属主机 (multihomed host)。</li><li>由于一个路由器至少应当连接到两个网络（这样它才能将 IP 数据报从一个网络转发到另一个网络），因此<strong>一个路由器至少应当有两个不同的 IP 地址</strong>。</li><li>两个路由器直接相连的接口处，可指明也可不指明 IP 地址。如指明IP 地址，则这一段连线就构成了一种只包含一段线路的特殊“网络”。现在常不指明 IP 地址。</li></ul></li><li><p>用转发器或网桥连接起来的若干个局域网仍为一个网络，因此这些局域网都具有同样的网络号net-id。</p></li><li><p>所有分配到网络号 net-id 的网络，无论是范围很小的局域网，还是覆盖很大地理范围的广域网，都是平等的。</p></li></ul><h4 id="ip地址的综合规划"><a class="markdownIt-Anchor" href="#ip地址的综合规划"></a> IP地址的综合规划</h4><ul><li>IP地址的综合应用是指将给定的IP地址块（或分类网络）划分成若干个更小的地址块（或子网），并将这些地址块（或子网）分配给互联网中的不同网络，进而可以给各网络中的主机和路由器的接口分配IP地址。</li><li>定长的子网掩码<ul><li>所划分出的每一个子网都使用同一个子网掩码。</li><li>每个子网所分配的IP地址数量相同，容易造成地址资源的浪费。</li><li><img src="/2024/06/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E7%BD%91%E7%BB%9C%E5%B1%82/6.png" class=""></li></ul></li><li>变长的子网掩码<ul><li>所划分出的每一个子网可以使用不同的子网掩码。</li><li>每个子网所分配的IP地址数量可以不同，尽可能减少对地址资源的浪费。</li><li><img src="/2024/06/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E7%BD%91%E7%BB%9C%E5%B1%82/7.png" class=""></li></ul></li></ul><h4 id="ip地址与mac地址"><a class="markdownIt-Anchor" href="#ip地址与mac地址"></a> IP地址与MAC地址</h4><ul><li><p>IP 地址与MAC地址（硬件地址或物理地址）是不同的地址。</p></li><li><p>封装位置</p><ul><li>MAC地址是数据链路层和物理层使用的地址。</li><li>IP 地址是网络层和以上各层使用的地址，是一种逻辑地址（是因为IP 地址是用软件实现的）。</li></ul></li><li><p>数据传送过程</p><ul><li>在数据包的传送过程中，数据包的源IP地址和目的IP地址保持不变；</li><li>在数据包的传送过程中，数据包的源MAC地址和目的MAC地址逐链路（或逐网络）改变。</li></ul></li></ul><h3 id="3-地址解析协议arp"><a class="markdownIt-Anchor" href="#3-地址解析协议arp"></a> 3、地址解析协议ARP</h3><ul><li><p>地址解析协议（Address Resolution Protocol，ARP）是一种在TCP/IP网络中用于将IP地址映射到物理MAC地址的协议。</p></li><li><p>每个主机都有一个ARP高速缓存，里面有所在的局域网上的各主机和路由器IP地址到MAC地址的映射表。<br />&lt; IP address；MAC address；TTL &gt; TTL (Time To Live)：地址映射有效时间</p></li><li><p>当主机A欲向本局域网上的某个主机B发送IP数据报时，先在其ARP高速缓存中查看有无主机B的IP地址。</p><ul><li>如有，就可查出其对应的硬件地址，再将此硬件地址写入MAC帧，通过局域网将该MAC帧发往此MAC地址。</li><li>如没有，ARP进程在本局域网上广播发送一个ARP请求分组。收到ARP响应分组后，将得到的IP地址到MAC地址的映射写入ARP高速缓存。</li></ul></li><li><p>转发表中的MAC地址与交换机接口号的对应关系记录也要周期性删除，因为这种对应关系并不是永久不变的。同理，ARP高速缓存表中的IP地址与MAC地址的对应关系也并不是永久不变的。例如，主机更换了一块新网卡。</p></li><li><p>ARP请求分组：包含发送方 MAC 地址 / 发送方 IP 地址 / 目标方 MAC 地址(未知时填0) / 目标方IP地址。</p></li><li><p>ARP响应分组：包含发送方 MAC 地址 / 发送方 IP地址 / 目标方 MAC 地址/ 目标方IP 地址。</p><ul><li>为了减少网络上的通信量，主机A在发送ARP请求分组时，将自己IP地址到MAC地址映射写入请求分组。</li><li>当主机B收到A的ARP请求分组时，将主机A的这一地址映射写入自己的ARP高速缓存中（方便以后发送）。</li></ul></li><li><p><strong>ARP 是解决同一个局域网上的主机或路由器的 IP 地址和MAC地址的映射问题</strong>。</p><ul><li>本地广播 ARP 请求（路由器不转发ARP请求）</li></ul></li><li><p>如果所要找的主机和源主机不在同一个局域网上，那么就要通过ARP找到一个位于本局域网上的某个路由器的MAC地址，然后把分组发送给这个路由器，让这个路由器把分组转发给下一个网络。</p></li><li><p>从IP地址到MAC地址的解析是自动进行的，主机的用户对这种地址解析过程是不知道的。</p><ul><li>只要主机或路由器要和本网络上的另一个已知IP地址的主机或路由器进行通信，ARP协议就会自动地将该IP地址解析为链路层所需要的MAC地址。</li></ul></li><li><p>ARP协议没有安全验证机制，存在ARP欺骗和攻击等问题。</p></li></ul><h3 id="4-ip数据报"><a class="markdownIt-Anchor" href="#4-ip数据报"></a> 4、IP数据报</h3><ul><li>一个IP数据报由首部和数据两部分组成。</li><li>IP数据报的首部：<ul><li>首部的前一部分是<strong>固定长度</strong>，共 <strong>20 字节</strong>，是所有IP数据报必须具有的。</li><li>首部固定部分的后面是一些可选字段，其长度是可变的。</li><li>IP数据报首部中的各字段或某些字段的组合，用来表达IP协议的相关功能。</li></ul></li></ul><img src="/2024/06/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E7%BD%91%E7%BB%9C%E5%B1%82/8.png" class=""><ul><li><p>版本</p><ul><li>长度为4个比特，用来表示IP协议的版本。</li><li>通信双方使用的IP协议的版本必须一致。</li><li>目前广泛使用的IP协议的版本号为4（即IPv4）。</li></ul></li><li><p>首部长度</p><ul><li>长度为4个比特，该字段的取值<strong>以4字节为单位</strong>，用来表示IP数据报的首部长度。</li><li>最小取值为二进制的0101，即十进制的5，再乘以4字节单位，表示IPv4数据报首部只有20字节固定部分。</li><li>最大取值为二进制的1111，即十进制的15，再乘以4字节单位，表示IPv4数据报首部包含20字节固定部分和最大40字节可变部分。</li></ul></li><li><p>可选字段</p><ul><li>长度从1字节到40字节不等（取决于所选的项目），用来支持排错、测量以及安全措施等功能。</li><li>虽然可选字段增加了IP数据报的功能，但这同时也使得IP数据报的首部长度成为可变的，这就增加了每一个路由器处理IP数据报的开销。</li><li>实际上，<strong>可选字段很少被使用</strong>。</li></ul></li><li><p>填充</p><ul><li>用来确保IP数据报的首部长度是4字节的整数倍，使用全0进行填充。</li><li>当首部长度（20字节固定部分+可变部分）的长度不是4字节整数倍时，填充相应数量的全0字节，以确保IP数据报的首部长度是4字节的整数倍。</li></ul></li><li><p>区分服务</p><ul><li>长度为8个比特，用来获得更好的服务。</li><li>利用该字段的不同取值可提供不同等级的服务质量。</li><li>只有在使用区分服务时该字段才起作用，一般情况下都不使用该字段。</li></ul></li><li><p>总长度</p><ul><li>长度为16个比特，该字段的取值以字节为单位，用来表示IP数据报的长度（首部长度+数据载荷长度）。</li><li>最大取值为二进制的16个比特1，即十进制的65535（很少传输这么长的IP数据报）。</li></ul></li><li><p>标识</p><ul><li>长度为16个比特，<strong>属于同一个IP数据报的各分片数据报应该具有相同的标识</strong>。</li><li>IP软件会维持一个计数器，每产生一个IP数据报，计数器值就加1，并将此值赋给标识字段。</li></ul></li><li><p>标志</p><ul><li>最低位（More Fragment，MF）<ul><li>MF=1表示本分片后还有分片</li><li>MF=0表示本分片后没有分片</li></ul></li><li>中间位（Don’t Fragment，DF）<ul><li>DF=1表示不允许分片</li><li>DF=0表示允许分片</li></ul></li><li>最高位为保留位，必须设置为0</li></ul></li><li><p>IP数据报分片</p><ul><li>原始数据报首部被复制为各数据报片的首部，但必须修改有关字段的值。</li><li>IP数据报越短，路由器转发的速度越快。</li><li>IP协议规定，在互联网中的所有主机和路由器必须能够接收长度不超过576字节的数据报。</li></ul></li><li><p>片偏移</p><ul><li>该字段的取值以8字节为单位，用来指出分片IP数据报的数据载荷偏移其在原IP数据报的位置有多远。</li><li>相对于用户数据字段的起点的偏移。</li><li><strong>除最后一个数据报分片，其他每个分片的长度一定是8字节的整数倍</strong>。</li></ul></li><li><p>生存时间（Time To Live，TTL）</p><ul><li>长度为8个比特，最大取值为二进制的11111111，即十进制的255。该字段的取值最初以秒为单位。因此，IP数据报的最大生存时间最初为255秒。路由器转发IP数据报时，将其首部中该字段的值减去该数据报在路由器上所耗费的时间，若结果不为0就转发，否则就丢弃。</li><li>生存时间字段后来改为<strong>以“跳数”为单位</strong>，路由器收到待转发的IP数据报时，将其首部中的该字段的值减1，若结果不为0就转发，否则就丢弃（<strong>数据报能在互联网中经过路由器的最大数值是256</strong>）。</li></ul></li><li><p>首部检验和</p><ul><li>长度为16个比特，检测IP数据报在传输过程中其首部是否出现了差错。（只检验首部，不包括数据部分）</li><li>IP数据报每经过一个路由器，其首部中的某些字段的值（例如生存时间TTL、标志以及片偏移等）都可能发生变化，因此路由器都要重新计算一下首部检验和。</li><li>IP首部检验和不采用复杂的循环冗余检验CRC，检错性能虽然不如CRC，但更易用软件实现。</li><li>计算方法：<ul><li><img src="/2024/06/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E7%BD%91%E7%BB%9C%E5%B1%82/9.png" class=""></li><li><img src="/2024/06/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E7%BD%91%E7%BB%9C%E5%B1%82/10.png" class=""></li></ul></li></ul></li><li><p>源IP地址</p><ul><li>长度为32个比特，用来填写发送IP数据报的源主机的IP地址。</li></ul></li><li><p>目的IP地址</p><ul><li>长度为32个比特，用来填写接收IP数据报的目的主机的IP地址。</li></ul></li></ul><h2 id="三-ip层转发分组的过程"><a class="markdownIt-Anchor" href="#三-ip层转发分组的过程"></a> 三、IP层转发分组的过程</h2><h3 id="1-基于终点的转发"><a class="markdownIt-Anchor" href="#1-基于终点的转发"></a> 1、基于终点的转发</h3><ul><li>分组的传送和转发是基于分组首部中的目的地址的，这种转发方式称为基于终点的转发。</li><li>IP数据报的传送和转发过程包含以下两个过程：<ul><li>主机发送IP数据报</li><li>路由器转发IP数据报</li></ul></li><li>分组每到达一个路由器，路由器就根据分组中的目的地址查找路由表。</li><li>路由器中的转发表是按照<strong>目的网络地址</strong>（网络前缀）来直接查找下一跳路由器的：<ul><li>若按目的主机地址来制作路由表，路由表就会过于庞大。</li><li>若按主机所在的网络地址来制作路由表，可使路由表大大简化。</li></ul></li><li>根据目的网络地址就能确定下一跳路由器：<ul><li>IP 数据报最终一定可以找到目的主机所在目的网络上的路由器（可能要通过多次的间接交付）。</li><li>只有到达最后一个路由器时，才试图向目的主机进行直接交付。</li></ul></li><li>路由器不转发广播IP数据报，即路由器隔离广播域。如果互联网中数量巨大的路由器收到广播IP数据报后进行转发，则会造成巨大的广播风暴，严重浪费资源。</li><li>主机路由（特定主机路由）<ul><li>虽然互联网所有的分组转发都是基于目的主机所在的网络，但在大多数情况下都允许有这样的特例，即为特定的目的主机指明一个路由。</li><li>采用特定主机路由可使网络管理人员能更方便地控制网络和测试网络，同时也可在需要考虑某种安全问题时采用这种特定主机路由。</li><li>主机路由在转发表中都放在最前面。</li><li><strong>主机路由的网络前缀：a.b.c.d/32</strong></li></ul></li><li>默认路由（默认网关）<ul><li>不管分组的目的网络在哪里，都由指定的路由器来处理。</li><li>采用默认路由可以减少路由表所占用的空间和搜索路由表所用的时间。</li><li>如果一个主机连接在一个小网络上，而这个网络只用一个路由器和互联网连接，那么在这种情况下使用默认路由是非常合适的。</li><li><strong>默认路由的网络前缀：0.0.0.0/0</strong></li></ul></li><li>两级IP地址（分类编址）下路由器分组转发算法<img src="/2024/06/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E7%BD%91%E7%BB%9C%E5%B1%82/11.png" class=""></li><li>划分子网情况下路由器分组转发算法<img src="/2024/06/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E7%BD%91%E7%BB%9C%E5%B1%82/12.png" class=""></li><li>IP 数据报的首部中没有地方可以用来指明“下一跳路由器的IP地址“。<ul><li>路由器收到数据报，不是将下一跳路由器的IP地址填入IP数据报，而是送交下层的网络接口软件。</li><li>网络接口软件使用ARP负责将下一跳路由器的IP地址转换成硬件地址，并将此硬件地址放在链路层的MAC帧的首部，然后根据这个硬件地址找到下一跳路由器。</li></ul></li><li>路由表没有给分组指明到某个网络的完整路径。<ul><li>路由表指出，到某个网络应当先到某个路由器（即下一跳路由器）。</li><li>在到达下一跳路由器后，再继续查找其路由表，知道再下一步应当到哪一个路由器。</li><li>这样一步一步地查找下去，直到最后到达目的网络。</li></ul></li><li>从 IP 地址得出网络地址：<ul><li>在不划分子网的两级IP地址下，从IP地址得出网络地址是个很简单的事。</li><li>但在划分子网的情况下，从IP地址却不能唯一地得出网络地址来，这是因为网络地址取决于那个网络所采用的子网掩码，但数据报的首部并没有提供子网掩码的信息。</li></ul></li></ul><h3 id="2-最长前缀匹配"><a class="markdownIt-Anchor" href="#2-最长前缀匹配"></a> 2、最长前缀匹配</h3><ul><li>使用无分类编址CIDR时，路由表中的每个项目由“网络前缀”和“下一跳地址”组成。</li><li>在查找路由表时可能会得到不止一个匹配结果。</li><li>最长前缀匹配 (longest-prefix matching)：从匹配结果中选择具有最长网络前缀的路由。<ul><li>最长前缀匹配又称为最长匹配或最佳匹配。</li><li>网络前缀越长，其地址块就越小，因而路由就越具体。</li></ul></li></ul><h3 id="3-使用二叉线索查找路由表"><a class="markdownIt-Anchor" href="#3-使用二叉线索查找路由表"></a> 3、使用二叉线索查找路由表</h3><ul><li>当路由表的项目数很大时，怎样设法减小路由表的查找时间就成为一个非常重要的问题。</li><li>为了进行更加有效的查找，通常是将无分类编址的路由表存放在一种层次的数据结构中，然后自上而下地按层次进行查找。</li><li>二叉线索 (binary trie)：一种特殊结构的树<ul><li>IP 地址中从左到右的比特值决定了从根节点逐层向下层延伸的路径。</li><li>二叉线索中的各个路径就代表路由表中存放的各个地址。</li><li>为了提高二叉线索的查找速度，广泛使用了各种压缩技术。</li></ul></li><li>唯一前缀（unique prefix）：在表中所有的IP地址中，该前缀是唯一的。</li><li><img src="/2024/06/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E7%BD%91%E7%BB%9C%E5%B1%82/13.png" class=""></li></ul><h2 id="四-网际控制报文协议icmp"><a class="markdownIt-Anchor" href="#四-网际控制报文协议icmp"></a> 四、网际控制报文协议ICMP</h2><h3 id="1-网际控制报文协议概述"><a class="markdownIt-Anchor" href="#1-网际控制报文协议概述"></a> 1、网际控制报文协议概述</h3><ul><li>网际控制报文协议（Internet Control Message Protocol，ICMP）<strong>为了更有效地转发IP数据报以及提高IP数据报交付成功的机会</strong>，ICMP 是互联网的标准协议 [RFC 792] 。</li><li>主机或路由器使用ICMP来发送差错报告报文和询问报文。</li><li><strong>ICMP报文是装在IP数据报中</strong>，作为其中的数据部分，看起来好像是高层协议，实际是IP层协议。<img src="/2024/06/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E7%BD%91%E7%BB%9C%E5%B1%82/14.png" class=""></li></ul><h3 id="2-网际控制报文的种类"><a class="markdownIt-Anchor" href="#2-网际控制报文的种类"></a> 2、网际控制报文的种类</h3><ul><li>ICMP 报文的种类有两种：<ul><li>ICMP 差错报告报文：用来向主机或路由器报告差错情况。</li><li>ICMP 询问报文：用来向主机或路由器询问情况。</li></ul></li></ul><h4 id="差错报告报文"><a class="markdownIt-Anchor" href="#差错报告报文"></a> 差错报告报文</h4><ul><li>终点不可达：当路由器或主机不能交付IP数据报时，就向源点发送终点不可达报文。<ul><li>具体可再根据ICMP的代码字段细分为目的网络不可达、目的主机不可达、目的协议不可达、目的端口不可达、目的网络未知、目的主机未知等13种。</li></ul></li><li>源点抑制：当路由器或主机由于拥塞而丢弃IP数据报时，就向发送该IP数据报的源点发送源点抑制报文，使源点知道应当把IP数据报的发送速率放慢。</li><li>时间超过（超时）：当路由器收到一个目的IP地址不是自己的IP数据报时，会将其首部中生存时间TTL字段的值减1。若结果为0，路由器丢弃该数据报，向发送该IP数据报的源点发送时间超过（超时）报文。当终点在预先规定的时间内未能收到一个数据报的<strong>全部数据报分片</strong>时，就把已收到的数据报片都丢弃，也会向源点发送时间超过（超时）报文。</li><li>参数问题：当路由器或目的主机收到IP数据报后，根据其首部中的检验和字段的值发现首部在传送过程中出现了误码，就丢弃该数据报，并向发送该数据报的源点发送参数问题报文。</li><li>改变路由（重定向）：路由器把改变路由报文发送给主机，让主机知道下次应将IP数据报发送给另外的路由器，这样可以通过更好的路由到达目的主机。</li><li>以下情况不应发送ICMP差错报告报文：<ul><li>对ICMP差错报告报文不再发送ICMP差错报告报文。</li><li>对第一个分片的IP数据报片的所有后续数据报片都不发送ICMP差错报告报文。</li><li>对具有多播地址的IP数据报都不发送ICMP差错报告报文。</li><li>对具有特殊地址（例如127.0.0.0或0.0.0.0）的IP数据报不发送ICMP差错报告报文。</li></ul></li><li><strong>所有的ICMP差错报告报文中的数据字段都具有同样的格式</strong>。</li></ul><h4 id="询问报文"><a class="markdownIt-Anchor" href="#询问报文"></a> 询问报文</h4><ul><li>回送请求或回答<ul><li>由主机或路由器向一个特定的目的主机或路由器发出。</li><li>收到此报文的主机或路由器必须给发送该报文的源主机或路由器发送ICMP回送回答报文。</li><li>这种询问报文用来<strong>测试目的站是否可达以及了解其有关状态</strong>。</li></ul></li><li>时间戳请求或回答<ul><li>用来请求某个主机或路由器回答当前的日期和时间。</li><li>利用在报文中的时间戳（如报文的发送时间和接收时间），发送方很容易计算出当前网络的往返时延。</li><li>这种询问报文用来进行时钟同步和测量时间。</li></ul></li></ul><h3 id="3-网际控制报文协议的应用举例"><a class="markdownIt-Anchor" href="#3-网际控制报文协议的应用举例"></a> 3、网际控制报文协议的应用举例</h3><h4 id="分组网间探测packet-internet-groperping"><a class="markdownIt-Anchor" href="#分组网间探测packet-internet-groperping"></a> 分组网间探测（Packet InterNet Groper，PING）</h4><ul><li>PING 用来测试两个主机之间的连通性。</li><li>PING 使用了 ICMP 回送请求与回送回答报文。</li><li>PING 是应用层直接使用网络层 ICMP 的例子，它没有通过运输层的TCP 或UDP。</li><li>某些主机或服务器为了防止恶意攻击，并会不理睬外界发来的ICMP回送请求报文。</li></ul><h4 id="跟踪路由traceroute"><a class="markdownIt-Anchor" href="#跟踪路由traceroute"></a> 跟踪路由（traceroute）</h4><ul><li>跟踪路由（traceroute）用于探测IP数据报从源主机到达目的主机要经过哪些路由器。</li><li>在Windows版本中，具体命令为“tracert”，其应用层直接使用网际层的ICMP协议，所使用的ICMP报文类型有回送请求和回答报文以及差错报告报文。</li></ul><h2 id="五-下一代网际协议ipv6"><a class="markdownIt-Anchor" href="#五-下一代网际协议ipv6"></a> 五、下一代网际协议IPv6</h2><h3 id="1-ipv6数据报的首部"><a class="markdownIt-Anchor" href="#1-ipv6数据报的首部"></a> 1、IPv6数据报的首部</h3><ul><li>IPv6 数据报由两大部分组成：<ul><li>基本首部 (base header)。</li><li>有效载荷或净负荷（payload），允许有零个或多个扩展首部 (extension header)，再后面是数据部分。</li></ul></li></ul><img src="/2024/06/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E7%BD%91%E7%BB%9C%E5%B1%82/15.png" class=""><ul><li>IPv6将IPv4数据报首部中不必要的功能取消了，这使得IPv6数据报基本首部中的字段数量减少到只有8个。</li><li>IPv6地址的长度扩展到了128比特，使得IPv6数据报基本首部的长度增大到了40字节，比IPv4数据报首部固定部分的长度（20字节）增大了20字节。</li><li>取消了首部长度字段，因为<strong>IPv6数据报的首部长度是固定的40字节</strong>。</li><li>取消了区分服务（服务类型）字段，因为IPv6数据报首部中的通信量 类和流标号字段实现了区分服务字段的功能。</li><li>取消了总长度字段，改用有效载荷长度字段。这是因为IPv6数据报的 首部长度是固定的40字节，只有其后面的有效载荷长度是可变的。</li><li>取消了标识、标志和片偏移字段，因为这些功能已包含在IPv6数据报的分片扩展首部中。</li><li>把生存时间TTL字段改称为跳数限制字段，这样名称与作用更加一致。</li><li>取消了协议字段，改用下一个首部字段。</li><li>取消了首部检验和字段，这样可以加快路由器处理IPv6数据报的速度。</li><li>取消了选项字段，改用扩展首部来实现选项功能。</li></ul><h4 id="基本首部"><a class="markdownIt-Anchor" href="#基本首部"></a> 基本首部</h4><ul><li>版本：长度为4比特，用来表示IP协议的版本。对于IPv6该字段的值是6。</li><li>通信量类：长度为8比特，该字段用来区分不同的IPv6数据报的类别或优先级。目前正在进行不同的通信量类性能的实验。</li><li>流标号：长度为20比特。<ul><li>IPv6提出了流的抽象概念。</li><li>流标号支持资源预分配。</li><li>“流”就是互联网上从特定源点到特定终点（单播或多播）的一系列IPv6数据报，而在这个流所经过的路径上的所有路由器都保证指明的服务质量。</li><li>所有属于同一个流的IPv6数据报都具有同样的流标号。</li><li>流标号对于实时音视频数据的传送特别有用，但对于传统的非实时数据，流标号则没有用处，把流标号字段的值置为0即可。</li></ul></li><li>有效载荷长度：长度为16比特，它指明IPv6数据报基本首部后面的有效载荷（包括扩展首部和数据部分）的字节数量。<ul><li>该字段以字节为单位，最大取值为65535，因此IPv6数据报基本首部后面的有效载荷的最大长度为65535字节。</li></ul></li><li>下一个首部：长度为8比特。该字段相当于IPv4数据报首部中的协议字段或可选字段。<ul><li>当IPv6数据报没有扩展首部时，该字段的作用与IPv4的协议字段一样，它的值指出了IPv6数据报基本首部后面的数据是何种协议数据单元PDU。（6——TCP、17——UDP）</li><li>当IPv6数据报基本首部后面带有扩展首部时，该字段的值就标识后面第一个扩展首部的类型。</li></ul></li><li>跳数限制：长度为8比特。该字段用来防止IPv6数据报在因特网中永久兜圈。<ul><li>源点在每个IPv6数据报发出时即设定某个跳数限制（最大255跳）。</li><li>每个路由器在转发IPv6数据报时，先把跳数限制字段中的值减1。当跳数限制的值为0时，把这个IPv6数据报丢弃（即不转发）。</li></ul></li><li>源地址字段和目的地址：长度都为128比特。分别用来填写IPv6数据报的发送端的IPv6地址和接收端的IPv6地址。</li></ul><h4 id="扩展首部"><a class="markdownIt-Anchor" href="#扩展首部"></a> 扩展首部</h4><ul><li>IPv4数据报如果在其首部中使用了选项字段，则在数据报的整个传送路径中的全部路由器，都要对选项字段进行检查，这就降低了路由器处理数据报的速度。</li><li>实际上，在路径中的路由器对很多选项是不需要检查的。<ul><li>IPv6把原来IPv4首部中选项的功能都放在扩展首部中；</li><li>将扩展首部留给<strong>路径两端的源站和目的站的主机来处理</strong>；</li><li>数据报<strong>传送路径中的所有路由器都不处理这些扩展首部</strong>（除逐跳选项扩展首部）。</li></ul></li><li>极大提高了路由器的处理效率。</li><li>在[RFC 8200]中定义了以下六种扩展首部：（1） 逐跳选项 （2） 路由选择 （3） 分片 （4） 鉴别 （5） 封装安全有效载荷 （6） 目的站选项</li><li>每一个扩展首部都由若干个字段组成，它们的长度也各不相同。</li><li><strong>所有扩展首部中的第一个字段都是“8比特的下一个首部字段”</strong>。</li><li>该字段的值指出在该扩展首部后面是何种扩展首部。</li><li>当使用多个扩展首部时，应按以上的先后顺序出现。</li></ul><h3 id="2-ipv6地址表示方法"><a class="markdownIt-Anchor" href="#2-ipv6地址表示方法"></a> 2、IPv6地址表示方法</h3><ul><li>在IPv6中，每个地址占128个比特。</li></ul><h4 id="冒号十六进制记法"><a class="markdownIt-Anchor" href="#冒号十六进制记法"></a> 冒号十六进制记法</h4><ul><li>每16比特分为1组，共8组</li><li>每组之间使用冒号“：”分割</li><li>将每组中的每4个比特转换为1个十六进制数</li></ul><h4 id="零压缩"><a class="markdownIt-Anchor" href="#零压缩"></a> 零压缩</h4><ul><li><p>在IPv6地址的冒号十六进制记法的基础上，再使用“左侧零”省略和“连续零”压缩，可使IPv6地址的表示更加简洁。</p><ul><li>“左侧零”省略是指两个冒号间的十六进制数中最前面的一串0可以省略不写。</li><li>“连续零”压缩是指一连串连续的0可以用一对冒号取代。</li></ul></li><li><p>在一个IPv6地址中<strong>只能使用一次“连续零”压缩</strong>，否则会导致歧义。</p></li><li><p>冒号十六进制记法还可结合点分十进制的后缀。这在IPv4向IPv6过渡阶段非常有用。</p><ul><li>0 : 0 : 0 : 0 : 0 : f f f f : 1 9 2 . 1 6 8 . 1 . 1<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">→</span></span></span></span>: : f f f f : 1 9 2 . 1 6 8 . 1 . 1</li></ul></li><li><p>CIDR的斜线表示法在IPv6中仍然可用。</p><ul><li>2 0 0 1 : 0 d b 8 : 0 0 0 0 : c d 3 0 : 0 0 0 0 : 0 0 0 0 : 0 0 0 0 : 0 0 0 0 / 6 0 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">→</span></span></span></span> 2 0 0 1 : d b 8 : 0 : c d 3 0 : : / 6 0</li></ul></li></ul><h3 id="3-ipv6地址的分类"><a class="markdownIt-Anchor" href="#3-ipv6地址的分类"></a> 3、IPv6地址的分类</h3><ul><li>IPv6数据报的目的地址可以是以下三种基本类型地址之一：<ul><li>单播 (unicast)：传统的点对点通信。</li><li>多播 (multicast)：一点对多点的通信，数据报发送到一组计算机中的每一个。IPv6没有采用广播的术语，而将广播看作多播的一个特例。</li><li>任播 (anycast)：这是 IPv6 增加的一种类型。任播的目的站是一组计算机，但数据报在交付时只交付其中的一个，通常是距离最近的一个。</li></ul></li><li>IPv6将实现IPv6的主机和路由器均称为节点。<ul><li>一个节点可能有多个与链路相连的接口。</li><li>IPv6地址是分配给节点上面的接口的（不是给某一个节点）。</li><li>一个具有多个接口的节点可有多个单播地址，其中的任何一个地址都可以当作到达该节点的目的地址。</li><li>一个节点接口的单播地址可用来唯一地标志该节点。</li></ul></li><li>[RFC 4291]对IPv6地址进行了分类：<ul><li>未指明地址<ul><li>这是16字节的全0地址，可缩写为两个冒号“::”。</li><li>不能用作目的地址，只能为还没有配置到一个标准的IP地址的主机当作源地址使用。</li><li>这类地址仅此一个。</li></ul></li><li>环回地址<ul><li>最低比特为1，其余127个比特为全0，即0:0:0:0:0:0:0:1（记为 ::1）。</li><li>作用和IPv4的环回地址一样。</li><li>这类地址也是仅此一个。</li></ul></li><li>多播地址<ul><li>最高8比特为全1的地址，可记为FF00::/8。</li><li>功能和IPv4的多播地址一样。</li><li>这类地址占IPv6地址总数的 1/256。</li></ul></li><li>本地站点单播地址（cite-local unicast address ）<ul><li>最高10比特为1111111011的地址，可记为FEC0::/10。</li><li>内部网络上的主机使用本地站点单播地址进行通信，不能和互联网上其他主机通信。</li><li>其用途和IPv4的专用地址是一样的。</li><li>这类地址占IPv6地址总数的1/1024。</li></ul></li><li>本地链路单播地址 (link-local unicast address)<ul><li>最高10比特为1111111010的地址，可记为FE80::/10。</li><li>在单一链路上使用（节点并没有连接在某个网络上）。</li><li>把分组发往单一链路的设备而不希望该分组被转发到此链路范围以外的地方。</li><li>这类地址占 IPv6 地址总数的 1/1024。</li></ul></li><li><strong>全球单播地址</strong><ul><li>IPv6的这一类单播地址是使用得最多的一类。</li><li>曾提出过多种方案来进一步划分这128位的单播地址。</li></ul></li></ul></li></ul><h3 id="4-从ipv4向ipv6过渡"><a class="markdownIt-Anchor" href="#4-从ipv4向ipv6过渡"></a> 4、从IPv4向IPv6过渡</h3><h4 id="双协议栈"><a class="markdownIt-Anchor" href="#双协议栈"></a> 双协议栈</h4><ul><li>双协议栈（dual stack）：在完全过渡到IPv6之前，使一部分主机或路由器装有IPv4和IPv6两套协议栈。</li><li>双协议栈主机或路由器既可以和IPv6系统通信，又可以和IPv4系统通信。</li><li>双协议栈主机或路由器记为IPv6/IPv4，表明它具有一个IPv6地址和一个IPv4地址。<ul><li>双协议栈主机在与IPv6主机通信时采用IPv6地址，而与IPv4主机通信时采用IPv4地址。</li><li>双协议栈主机通过域名系统DNS查询目的主机采用的IP地址：<ul><li>若DNS返回的是IPv4地址，则双协议栈的源主机就使用IPv4地址；</li><li>若DNS返回的是IPv6地址，则双协议栈的源主机就使用IPv6地址。</li></ul></li></ul></li></ul><h4 id="隧道技术"><a class="markdownIt-Anchor" href="#隧道技术"></a> 隧道技术</h4><ul><li>当IPv6数据报要进入IPv4网络时，将IPv6数据报重新封装成IPv4数据报，即整个IPv6数据报成为IPv4数据报的数据载荷。</li><li>封装有IPv6数据报的IPv4数据报在IPv4网络中传输。</li><li>当IPv4数据报要离开IPv4网络时，再将其数据载荷（即原来的IPv6数据报）取出并转发到IPv6网络。</li></ul><h3 id="5-网际控制报文协议icmpv6"><a class="markdownIt-Anchor" href="#5-网际控制报文协议icmpv6"></a> 5、网际控制报文协议ICMPv6</h3><ul><li>由于IPv6与IPv4一样，都不确保数据报的可靠交付，因此IPv6也需要使用网际控制报文协议ICMP来向发送IPv6数据报的源主机反馈一些差错信息。</li><li>ICMPv6比ICMPv4要复杂得多，它合并了原来的地址解析协议ARP和网际组管理协议IGMP的功能。</li><li>ICMPv6报文需要封装成IPv6数据报进行发送。</li><li>ICMPv6报文可被用来报告差错、获取信息、探测邻站或管理多播通信。</li></ul><h2 id="六-路由器和路由选择协议"><a class="markdownIt-Anchor" href="#六-路由器和路由选择协议"></a> 六、路由器和路由选择协议</h2><h3 id="1-路由器的构成和基本工作原理"><a class="markdownIt-Anchor" href="#1-路由器的构成和基本工作原理"></a> 1、路由器的构成和基本工作原理</h3><ul><li><p>路由器是一种具有多个输入端口和输出端口的专用计算机，其<strong>任务是转发分组</strong>。路由器是一种典型的<strong>网络层设备</strong>。</p></li><li><p>路由器的主要作用是：</p><ul><li>连通不同的网络。</li><li>选择信息传送的线路。</li></ul></li><li><p>路由器结构可划分为两大部分：</p><ul><li><strong>路由选择部分</strong>：也叫做控制部分，其核心构件是<strong>路由选择处理机</strong>。路由选择处理机的任务是根据所选定的路由选择协议构造出路由表，同时定期和相邻路由器交换路由信息而不断地更新和维护路由表。</li><li><strong>分组转发部分</strong>（三部分组成）：<ul><li><strong>交换结构</strong> (switching fabric)：又称交换组织，是根据转发表 (forwarding table) 对分组进行处理。</li><li><strong>一组输入端口</strong></li><li><strong>一组输出端口</strong></li></ul></li></ul></li><li><p>路由选择：根据从各相邻路由器得到的关于网络拓扑变化情况，动态地改变所选择的路由。</p></li><li><p>分组转发：路由器根据转发表将用户的IP数据报从合适的端口转发出去。</p></li><li><img src="/2024/06/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E7%BD%91%E7%BB%9C%E5%B1%82/16.png" class=""></li><li><p>实现交换结构的三种基本方式是：通过存储器、通过总线以及通过互连网络。这三种交换结构可实现的路由器转发速率依次提高。</p></li></ul><h4 id="输入端口"><a class="markdownIt-Anchor" href="#输入端口"></a> 输入端口</h4><ul><li>输入端口里面装有物理层、数据链路层和网络层的处理模块。</li><li>数据链路层剥去帧首部和尾部后，将分组送到网络层的队列中排队等待处理。这会产生一定的时延。</li><li><strong>输入端口中的查找和转发功能在路由器的交换功能中是最重要的</strong>。</li></ul><h4 id="输出端口"><a class="markdownIt-Anchor" href="#输出端口"></a> 输出端口</h4><ul><li>输出端口里面装有物理层、数据链路层和网络层的处理模块。</li><li>输出端口从交换结构接收分组，然后把它们发送到路由器外面的线路上。</li><li>在网络层的处理模块中设有一个缓冲区（队列）。当交换结构传送过来的分组的速率超过输出链路的发送速率时，来不及发送的分组就必须暂时存放在这个队列中。</li><li>数据链路层处理模块将分组加上链路层的首部和尾部，交给物理层后发送到外部线路。</li><li>路由器中的<strong>输入或输出队列产生溢出</strong>是造成分组丢失的重要原因。</li></ul><h4 id="交换结构"><a class="markdownIt-Anchor" href="#交换结构"></a> 交换结构</h4><ul><li>交换结构是路由器的关键构件：把分组从一个输入端口转移到某个合适的输出端口。</li><li>常用交换方法有三种：<ul><li>通过存储器<ul><li>当路由器的某个输入端口收到一个分组时，就用中断方式通知路由选择处理机。然后分组就从输入端口复制到存储器中。</li><li>存储器的带宽（读或写）为每秒 M 个分组，那么路由器的交换速率（即分组从输入端口传送到输出端口的速率）<strong>一定小于 M/2</strong>。</li></ul></li><li>通过总线<ul><li>数据报从输入端口通过共享的总线直接传送到合适的输出端口，而不需要路由选择处理机的干预。</li><li>路由器的转发带宽就受总线速率的限制。</li></ul></li><li>通过互连网络<ul><li>也称为通过纵横交换结构。</li><li>输入端口收到分组时，就将它发送到与该输入端口相连的水平总线上。</li><li>若输出端口的垂直总线是空闲的，则将垂直总线与水平总线接通，将该分组转发到这个输出端口。</li><li>若已被占用，则后到达的分组就被阻塞，必须在输入端口排队。</li></ul></li></ul></li></ul><h3 id="2-有关路由选择协议的基本概念"><a class="markdownIt-Anchor" href="#2-有关路由选择协议的基本概念"></a> 2、有关路由选择协议的基本概念</h3><ul><li>关于“最佳路由”：<ul><li>不存在一种绝对的最佳路由算法。</li><li>所谓“最佳”只能是相对于某一种特定要求下得出的较为合理的选择而已。</li></ul></li><li>路由选择的分类（基于自适应性）<ul><li>静态路由选择策略<ul><li>采用人工配置的方式给路由器添加网络路由、默认路由和特定主机路由等路由条目。</li><li>静态路由选择简单、开销小，但不能及时适应网络状态（流量、拓扑等）的变化。</li><li>静态路由选择一般只在小规模网络中采用。</li></ul></li><li>动态路由选择策略<ul><li>路由器通过路由选择协议自动获取路由信息。</li><li>动态路由选择比较复杂、开销比较大，但能较好地适应网络状态的变化。</li><li>动态路由选择适用于大规模网络。</li></ul></li></ul></li></ul><h3 id="3-静态路由选择"><a class="markdownIt-Anchor" href="#3-静态路由选择"></a> 3、静态路由选择</h3><ul><li><p>默认路由</p><img src="/2024/06/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E7%BD%91%E7%BB%9C%E5%B1%82/17.png" class=""></li><li><p>特定主机路由</p><img src="/2024/06/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E7%BD%91%E7%BB%9C%E5%B1%82/18.png" class=""><ul><li>出于某种安全问题的考虑，同时为了使网络运维人员更方便地控制网络和测试网络，特别是在对网络的连接或路由表进行排错时，指明到某一台主机的特定主机路由是十分有用的。</li></ul></li></ul><h3 id="4-互联网分层次的路由选择协议"><a class="markdownIt-Anchor" href="#4-互联网分层次的路由选择协议"></a> 4、互联网分层次的路由选择协议</h3><ul><li><p>互联网路由选择协议的特点：</p><ul><li>自适应：采用动态路由选择，能较好地适应网络状态的变化。</li><li>分布式：各路由器通过相互间的信息交互，共同完成路由信息的获取和更新。</li><li>分层次：将整个因特网划分为许多较小的自治系统（Autonomous System，AS），在自治系统内部和外部采用不同类别的路由选择协议，分别进行路由选择。</li></ul></li><li><p>自治系统AS（Autonomous System，AS），在单一的技术管理下的一组路由器，而这些路由器使用一种<strong>AS内部的路由选择协议</strong>和共同的度量以确定分组在该AS内的路由，同时还使用一种<strong>AS之间的路由选择协议</strong>用以确定分组在AS之间的路由。</p></li><li><p>内部网关协议（Interior Gateway Protocol，IGP）：在一个自治系统内部使用的路由选择协议。</p></li><li><p>外部网关协议（External Gateway Protocol，EGP）：不同自治系统之间使用的路由选择协议。</p></li><li><p>一个AS对其他AS表现出的是一个单一的和一致的路由选择策略。</p></li><li><p>外部网关协议EGP和内部网关协议IGP只是路由选择协议的分类名称，而不是具体的路由选择协议。</p></li><li><p>在自治系统内部的路由选择叫做<strong>域内路由选择</strong>。</p></li><li><p>自治系统之间的路由选择也叫做<strong>域间路由选择</strong>。</p></li><li><p>常见的内部网关协议IGP/域内路由选择协议：RIP协议和OSPF协议。</p></li><li><p>常见的外部网关协议EGP/域间路由选择协议：BGP协议。</p></li></ul><h3 id="5-内部网关协议路由信息协议rip"><a class="markdownIt-Anchor" href="#5-内部网关协议路由信息协议rip"></a> 5、内部网关协议——路由信息协议RIP</h3><ul><li><p>路由信息协议RIP是一种分布式的基于距离向量（Distance-Vector，D-V）的路由选择协议。</p><ul><li>RIP要求自治系统AS内的每一个路由器，都要维护从它自己到AS内其他每一个目的网络的距离记录。</li><li>RIP使用跳数（Hop Count）作为度量来衡量到达目的网络的距离（“距离”指的是“最短距离”）。</li></ul></li><li><p>距离的定义：</p><ul><li>RIP将路由器到直连网络的距离定义为1。</li><li>RIP将路由器到非直连网络的距离定义为所经过的路由器数加1。</li><li>RIP允许一条路径最多包含15个路由器，距离等于16时相当于不可达（<strong>RIP只适用于小型互联网</strong>）。</li></ul></li><li><p>RIP不能在两个网络之间同时使用多条路由。</p></li><li><p>RIP认为，好的路由就是“距离短”的路由，也就是所通过路由器数量最少的路由，哪怕还存在另一条高速（低时延）但路由器较多的路由。</p></li><li><p>当到达同一目的网络有多条RIP距离相等的路由时，可以进行等价负载均衡，也就是将通信量均衡地分布到多条等价的路径上。</p></li><li><p>RIP协议三个特点：</p><ul><li>和谁交换信息？——仅和相邻路由器交换信息。</li><li>交换什么信息？——当前本路由器所知道的全部信息，即路由器的路由表（即本路由器到所在自治系统AS中各网络的最短RIP距离，以及到各网络应经过的下一跳路由器）。</li><li>何时交换信息？——按<strong>固定的时间间隔</strong>交换路由信息，为了加快RIP的收敛速度，当网络拓扑发生变化时，路由器要及时向相邻路由器通告拓扑变化后的路由信息，这称为<strong>触发更新</strong>。</li></ul></li><li><p>路由表的建立：</p><ul><li>自己到直连网络的RIP距离为1。</li><li>每个路由器仅和相邻路由器周期性地交换并更新路由信息。</li><li>若干次更新后，所有的路由器最终都会知道到达本AS中任何一个网络的最短距离和下一跳路由器的地址。</li><li>RIP 协议的收敛 (convergence) 较快，收敛就是在AS中所有的节点都得到正确的路由选择信息的过程。</li></ul></li><li><p>路由器收到相邻路由器（其地址为X）的一个RIP报文，执行如下过程：</p><ul><li>先修改此RIP报文中的所有项目：把“下一跳”字段中的地址都改为X，并把所有的“距离”字段的值加1。</li><li>对修改后的RIP报文中的每一个项目，重复以下步骤：<ul><li>若项目中的目的网络不在路由表中，则把该项目加到路由表中。<ul><li>否则，若下一跳字段给出的路由器地址是同样的，则把收到的项目替换原路由表中的项目。<ul><li>否则，若收到项目中的距离小于路由表中的距离，则进行更新，<ul><li>否则，什么也不做。</li></ul></li></ul></li></ul></li></ul></li></ul></li><li><p>除了上述RIP路由条目更新规则，在RIP的距离向量算法中还包含以下一些时间参数：</p><ul><li>路由器每隔大约30秒向其所有相邻路由器发送路由更新报文。</li><li>若180秒（默认）没有收到某条路由条目的更新报文，则把该路由条目标记为无效（即把RIP距离设置为16，表示不可达），若再过一段时间（如120秒），还没有收到该路由条目的更新报文，则将该路由条目从路由表中删除。</li></ul></li><li><p>RIP协议的特点：<strong>好消息传播得快，坏消息传播得慢</strong>。</p></li><li><p>当网络出现故障时，要经过比较长的时间（例如数分钟）才能将此信息传送到所有的路由器。</p></li><li><p>坏消息传播得慢的问题又被称为路由环路或RIP距离无穷计数问题。这是距离向量算法的一个固有问题。可以采取以下多种措施减少出现该问题的概率或减小该问题带来的危害：</p><ul><li>限制最大RIP距离为15（16表示不可达）。</li><li>当路由表发生变化时就立即发送路由更新报文（即“触发更新”），而不仅是周期性发送。</li><li>路由器记录收到某个路由信息的接口，不让同一路由信息再通过此接口反方向传送（即“水平分割”）。</li><li>使用上述措施仍无法彻底解决问题。因为在距离向量算法中，每个路由器都缺少到目的网络整个路径的完整信息，无法判断所选的路由是否出现了环路。</li></ul></li><li><p>RIP相关报文使用运输层的用户数据报协议UDP进行封装，使用的UDP端口号为520。</p></li></ul><img src="/2024/06/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E7%BD%91%E7%BB%9C%E5%B1%82/19.png" class=""><h3 id="6-内部网关协议开放最短路径优先ospf"><a class="markdownIt-Anchor" href="#6-内部网关协议开放最短路径优先ospf"></a> 6、内部网关协议——开放最短路径优先OSPF</h3><ul><li>OSPF是基于链路状态的，而不像RIP是基于距离向量的，采用分布式的链路状态协议（Link State Protocol）。</li><li>OSPF基于链路状态并采用最短路径算法计算路由，从算法上保证了不会产生路由环路。</li><li>OSPF不限制网络规模（可再划分若干小区域），更新效率高，收敛速度快。</li><li>OSPF协议的三个特点：<ul><li>向本自治系统中所有路由器发送信息，这里使用的方法是<strong>洪泛法</strong>（flooding）。<ul><li>路由器通过所有输出端口向所有相邻的路由器发送信息，每一个相邻路由器又再将此信息发往其他所有的相邻路由器（除刚发来信息的那个路由器），直到所有路由器都得到了这个信息的副本。</li></ul></li><li>发送的信息就是与本路由器相邻的所有路由器的链路状态，但这只是路由器所知道的<strong>部分信息</strong>。<ul><li><strong>“链路状态”就是说明本路由器都和哪些路由器相邻，及该链路的“度量“（metric）或“代价”</strong>。</li></ul></li><li>只有当链路状态发生变化或每隔一段时间，路由器才用洪泛法向所有路由器发送此信息。</li></ul></li><li>由于各路由器之间频繁地交换链路状态信息，因此所有的路由器最终都能建立一个<strong>链路状态数据库</strong>。</li><li>这个数据库实际上就是全网的拓扑结构图，它在全网范围内是一致的（这称为链路状态数据库的同步）。</li><li>OSPF 的链路状态数据库能较快地进行更新，使各个路由器能及时更新其路由表。</li><li><strong>OSPF 的更新过程收敛得快是其重要优点</strong>。</li></ul><h4 id="链路代价的计算"><a class="markdownIt-Anchor" href="#链路代价的计算"></a> 链路代价的计算</h4><ul><li>链路状态是指哪些路由器相邻以及链路的“代价“（表示费用、距离、时延和带宽等，由网络管理人员决定）。</li></ul><img src="/2024/06/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E7%BD%91%E7%BB%9C%E5%B1%82/20.png" class=""><h4 id="邻居关系的建立和维护"><a class="markdownIt-Anchor" href="#邻居关系的建立和维护"></a> 邻居关系的建立和维护</h4><ul><li>OSPF相邻路由器之间通过交互问候（Hello）分组来建立和维护邻居关系。</li><li><strong>问候分组封装在IP数据报中</strong>，发往组播地址224.0.0.5。IP数据报首部中的协议号字段的取值为89，表明IP数据报的数据载荷为OSPF分组。<ul><li>OSPF分组直接使用网络层的IP数据报进行封装，RIP报文需要使用运输层用户数据报协议UDP封装。</li><li><strong>从数据按网络体系结构逐层封装的角度看，OSPF属于网络层协议，而RIP属于应用层协议</strong>（但其核心功能是路由选择，属于网络层）。</li></ul></li><li>每个路由器都会建立一张邻居表。</li><li>问候分组的发送周期为10秒。</li><li>若40秒未收到，认为邻居不可达。</li></ul><h4 id="链路状态通告"><a class="markdownIt-Anchor" href="#链路状态通告"></a> 链路状态通告</h4><ul><li>使用OSPF的每个路由器都会产生<strong>链路状态通告</strong>（Link State Advertisement，LSA）。<ul><li>直连网络的链路状态信息。</li><li>邻居路由器的链路状态信息。</li></ul></li></ul><h4 id="链路状态更新分组"><a class="markdownIt-Anchor" href="#链路状态更新分组"></a> 链路状态更新分组</h4><ul><li>链路状态通告被封装在链路状态更新（Link State Update，LSU）分组中，采用可靠的洪泛法进行发送。</li><li>洪泛法的要点是路由器向自己所有的邻居路由器发送链路状态更新分组，收到该分组的各路由器又将该分组转发给自己所有的邻居路由器（但其上游路由器除外），以此类推。</li><li><strong>可靠是指收到链路状态更新分组后要发送确认</strong>，收到重复的更新分组无需再次转发，但要发送一次确认。</li><li>通过各路由器洪泛发送封装有各自链路状态通告LSA的链路状态更新LSU分组，各路由器的链路状态数据库LSDB最终将达到一致。</li></ul><h4 id="基于链路状态数据库进行最短路径优先计算"><a class="markdownIt-Anchor" href="#基于链路状态数据库进行最短路径优先计算"></a> 基于链路状态数据库进行最短路径优先计算</h4><ul><li>基于链路状态数据库LSDB进行最短路径优先计算，构建出各自到达其他各路由器的最短路径，即路由表。</li></ul><h4 id="五种分组类型"><a class="markdownIt-Anchor" href="#五种分组类型"></a> 五种分组类型</h4><ul><li>问候 （Hello）：用来发现和维护邻居路由器的可达性。</li><li>数据库描述 （Database Description）：用来向邻居路由器给出自己的链路状态数据库中的所有链路状态项目的摘要信息。</li><li>链路状态请求 （Link State Request）：用来向邻居路由器请求发送某些链路状态项目的详细信息。</li><li>链路状态更新 （Link State Update）：路由器使用链路状态更新分组将其链路状态信息进行洪泛发送，即用 洪泛法对整个系统更新链路状态。</li><li>链路状态确认 （Link State Acknowledgement）：对链路状态更新分组的确认分组。</li></ul><h4 id="减少洪泛广播"><a class="markdownIt-Anchor" href="#减少洪泛广播"></a> 减少洪泛（广播）</h4><ul><li>为了减少洪泛发送问候分组和链路状态更新分组的数量，OSPF采用以下措施：<ul><li>选举<strong>指定路由器</strong>（Designated Router，DR）和<strong>备用指定路由器</strong>（Backup Designated Router，BDR）。</li><li>所有非DR/BDR只与DR/BDR建立邻居关系。</li><li>非DR/BDR之间通过DR/BDR交换信息。</li></ul></li></ul><h4 id="划分区域"><a class="markdownIt-Anchor" href="#划分区域"></a> 划分区域</h4><ul><li><p>为了使OSPF协议能够用于规模大的网络，OSPF把一个自治系统AS再划分为若干个更小的范围——区域（area）。</p></li><li><p>好处：<strong>把利用洪泛法交换链路状态信息的范围局限于每一个区域，这样就减少了整个网络上的通信量</strong>。</p></li><li><p>采用划分区域的方法，虽然使交换信息的种类增多了，同时也使OSPF协议更加复杂了，但这样做能使每一个区域内部交换路由信息的通信量大大减小，因而使OSPF协议能够用于规模更大的自治系统AS。</p></li></ul><h4 id="其它特点"><a class="markdownIt-Anchor" href="#其它特点"></a> 其它特点</h4><ul><li>OSPF不用UDP而是直接用IP数据报传送。</li><li>OSPF构成的数据报很短，减少路由信息的通信量。</li><li>OSPF可根据IP分组的不同服务类型TOS而设置成不同的代价，对于不同类型业务可计算出不同的路由。</li><li>同一个目的网络有多条相同代价的路径，可将通信量分配给这几条路径，这叫做多路径间的负载平衡。</li><li>所有在OSPF路由器之间交换的分组都具有鉴别的功能（可信赖的路由间交换信息）。</li><li>支持可变长度的子网划分和无分类的编址</li><li>每一个链路状态都带上一个 32 位的序号，序号越大状态就越新。</li><li>OSPF还规定每隔一段时间（如30分钟），要刷新一次数据库中的链路状态。</li><li><strong>由于一个路由器的链路状态只涉及到与相邻路由器的连通状态，因而与整个互联网的规模并无直接关系。因此当互联网规模很大时，OSPF协议要比距离向量协议RIP好得多</strong>。</li><li>OSPF没有“坏消息传播得慢”的问题，据统计，其响应网络变化的时间小于100ms。</li></ul><h3 id="7-边界网关协议bgp"><a class="markdownIt-Anchor" href="#7-边界网关协议bgp"></a> 7、边界网关协议BGP</h3><ul><li>边界网关协议（Border Gateway Protocol，BGP）属于外部网关协议EGP这个类别，用于自治系统AS之间的路由选择协议。</li><li>BGP力求寻找一条能够到达目的网络且<strong>比较好的路由（不能兜圈子）</strong>，而<strong>并非要寻找一条最佳路由</strong>。</li><li>互联网的规模太大，对于自治系统之间的路由选择，要寻找最佳路由是很不现实的。<ul><li>不同AS内度量路由的代价可能不同，对于AS之间的路由选择，使用统一的代价寻找最佳是不行的。</li></ul></li><li>AS之间的路由选择还必须考虑有关策略（政治、经济、安全等）。</li><li>在配置BGP时，每个AS的管理员要选择至少一个路由器作为该AS的“BGP发言人”。</li><li>一般来说，两个BGP发言人都是通过一个共享网络连接在一起的，而<strong>BGP发言人往往就是BGP边界路由器</strong>。</li><li>BGP发言人除了运行BGP协议外，还必须运行自己所在AS所使用的内部网关协议IGP，例如RIP或OSPF。</li><li>BGP发言人之前交换路由信息，先<strong>建立TCP连接</strong>，在此连接上<strong>建立BGP会话</strong>，利用<strong>BGP会话交换路由信息</strong>。</li><li>使用TCP连接能提供可靠的服务，也简化了路由选择协议。</li><li>使用TCP连接交换路由信息的两个BGP发言人，彼此称为对方的邻站（neighbor）或对等站（peer）。</li><li>BGP发言人交换网络可达性的信息：要到达某个网络所要经过的一系列自治系统。</li><li>当BGP发言人相互交换了网络可达性的信息后，各BGP发言人就根据所采用的策略，<strong>从收到的路由信息中找出到达各自治系统的较好的路由</strong>，也就是<strong>构造出树形结构且不存在环路的自治系统连通图</strong>。</li><li>BGP适用于多级结构的互联网。</li><li>BGP协议交换路由信息的节点数量级是自治系统数的量级，这要比这些自治系统中的网络数少很多。</li><li>每一个自治系统中BGP发言人（或边界路由器）的数目是很少的，使得自治系统之间的路由选择不过分复杂。</li><li>BGP支持 CIDR，BGP路由表包括目的网络前缀、下一跳路由器，和到达该目的网络所要经过的自治系统序列。</li><li>在BGP刚刚运行时，BGP的邻站是交换整个的BGP路由表。但以后只需要在发生变化时更新有变化的部分。这样做对节省网络带宽和减少路由器的处理开销都有好处。</li></ul><h4 id="路由"><a class="markdownIt-Anchor" href="#路由"></a> 路由</h4><ul><li>一个自治系统有两种不同的路由器：边界路由器和内部路由器。</li><li>边界路由器R1和R2之间建立TCP连接，这种TCP又称为半永久性连接（eBGP连接），向对等端发送BGP路由。</li><li><strong>在AS内部</strong>，路由器之间还需要建立TCP连接（iBGP连接），向内部的其他路由器传送BGP报文。<ul><li>规定，AS内部所有的iBGP必须是<strong>全连通的</strong>。</li><li>即使两个路由器之间没有物理连接，也有iBGP连接。</li></ul></li><li>路由通告规则：<ul><li>从eBGP对等端收到的BGP路由，通告给所有对等端 (iBGP/eBGP)。</li><li>从iBGP对等端收到的BGP路由，可通过eBGP通告给不在同一AS的对等端。</li><li>从iBGP对等端收到的BGP路由，不能通告给同一个AS内不同iBGP的对等端（<strong>水平分割原则</strong>）。</li></ul></li><li>BGP协议用来解决在众多AS之间的路由选择问题。<ul><li>eBGP连接用于在<strong>不同的AS之间交换路由信息</strong>。</li><li>iBGP连接用于在<strong>AS内部交换路由信息</strong>。</li></ul></li><li>每一个AS中，还<strong>必须运行内部网关协议IGP</strong>。<img src="/2024/06/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E7%BD%91%E7%BB%9C%E5%B1%82/21.png" class=""></li><li>BGP路由的一般格式“X，AS，R”（从R出发，经过AS，就能到达X）</li><li><strong>前缀</strong>：通告的BGP路由<strong>终点</strong>（子网前缀）。</li><li><strong>BGP属性</strong>中最重要两个类型：AS-PATH 和 NEXT-HOP。<ul><li>AS-PATH （自治系统路径）是通告的BGP路由所经过的自治系统。</li><li>NEXT-HOP （下一跳）是通告的BGP路由起点。</li></ul></li><li>路由器构造自己转发表：<strong>两次递归查找</strong>。</li></ul><img src="/2024/06/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E7%BD%91%E7%BB%9C%E5%B1%82/22.png" class=""><ul><li>R4要把这条BGP路由的<strong>起点进行转换</strong>。<ul><li>把BGP路由的起点改为R1的对等端R2 ，把BGP路由变为“R2→ R1→X”。</li></ul></li><li>利用内部网关协议，找到从R4到R2的最佳路由中的下一跳。<ul><li>本例中，假设查出下一跳是R3。于是R4在转发表中增加了到达前缀X的下一跳是R3这一项目。</li></ul></li><li>用类似的方法，路由器R<sub>3</sub>也在自己的转发表中增加了到达前缀X的项目。</li><li>路由器R<sub>4</sub>只要收到要到达前缀X的分组，都按照R<sub>4</sub>→R<sub>3</sub>→R<sub>2</sub>→R<sub>1</sub>→X的路径， 最后到达前缀X。</li></ul><h4 id="三种不同的自治系统as"><a class="markdownIt-Anchor" href="#三种不同的自治系统as"></a> 三种不同的自治系统AS</h4><ul><li>末梢AS（stub AS）：发送分组给<strong>直连的AS</strong>或<strong>从直连的AS</strong>接受分组或发送分组，不会把来自其他AS的分组再转发到另一个AS。<ul><li>多归属AS：同时连接两个或以上的AS，增加链接的可靠性，不允许分组穿越自己的自治系统。</li><li>末梢AS必须向所连接的AS付费才能发送或接收分组。</li></ul></li><li>穿越AS（transit AS）：高速通信干线的主干AS，其任务就是<strong>为其他的AS有偿转发分组</strong>。</li><li>对等AS（peering AS）：事先协商的两个AS，彼此之间的发送或接收分组<strong>不收费</strong>。</li></ul><h4 id="路由选择"><a class="markdownIt-Anchor" href="#路由选择"></a> 路由选择</h4><ul><li>若到前缀X有两条或更多的BGP路由可供选择，那么就应当根据以下的原则，按照给出的先后顺序，选择一条较好 的BGP路由。<ul><li>本地偏好（local preference）值最高的路由。 根据政治或经济上的策略来设置。</li><li>选择具有AS跳数最少的路由。（不一定是最佳路由）</li><li>使用<strong>热土豆路由选择算法</strong>。<ul><li>两条BGP路由本地偏好相同。</li><li>两条BGP路由经过AS的跳数相同。</li><li><strong>最少转发次数</strong>到达下一个AS。</li></ul></li><li>选择路由器BGP<strong>标识符的数值最小</strong>的路由。<ul><li>在BGP报文中，首部有一个4字节的BGP标识符字段（BGP ID）。</li><li>具有多个接口的路由器的BGP ID就是该路由器中IP地址中数值最大的一个。</li></ul></li></ul></li></ul><h4 id="报文"><a class="markdownIt-Anchor" href="#报文"></a> 报文</h4><ul><li>BGP共使用四种报文，<strong>四种BGP报文具有同样的首部</strong>。<ul><li>打开报文（OPEN）：用来与相邻的另一个BGP发言人（对等端）建立关系。</li><li>更新报文（UPDATE）：用来通告某一条路由的信息，以及列出要撤销的路由。</li><li>保活报文（KEEPALIVE）：用来周期性地证实与对等端的连通性。</li><li>通知报文（NOTIFICATION）：用来发送检测到的差错。</li></ul></li><li><strong>BGP报文使用TCP报文的数据部分来传送的</strong>（TCP连接端口号179）。</li></ul><h3 id="8-rip-ospf和bgp三种路由协议的比较"><a class="markdownIt-Anchor" href="#8-rip-ospf和bgp三种路由协议的比较"></a> 8、RIP, OSPF和BGP三种路由协议的比较</h3><img src="/2024/06/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E7%BD%91%E7%BB%9C%E5%B1%82/23.png" class=""><h2 id="七-虚拟专用网和网络地址转换"><a class="markdownIt-Anchor" href="#七-虚拟专用网和网络地址转换"></a> 七、虚拟专用网和网络地址转换</h2><h3 id="1-专用网"><a class="markdownIt-Anchor" href="#1-专用网"></a> 1、专用网</h3><ul><li>由于IP地址的紧缺，一个机构能够申请到的IP地址数往往远小于本机构所拥有的主机数。</li><li>考虑到互联网并不很安全，<strong>一个机构内也并不需要把所有的主机接入到外部的互联网</strong>。<ul><li>那么从原则上讲，对于这些仅在机构内部使用的计算机就可以<strong>由本机构自行分配其IP地址</strong>。</li></ul></li><li>两种地址：<ul><li>本地地址：仅在机构内部使用的IP地址，可以由本机构自行分配，而不需要向互联网的管理机构申请。</li><li>全球地址：全球唯一的IP地址，必须向互联网的管理机构申请。</li></ul></li><li><strong>专用地址只能用作本地地址而不能用作全球地址</strong>。</li><li>专用地址仅在本机构内部使用。专用IP地址也叫做可重用地址（reusable address）。</li><li>采用这样的专用IP地址的互连网络称为专用互联网或本地互联网，就叫做专用网。</li></ul><h3 id="2-虚拟专用网"><a class="markdownIt-Anchor" href="#2-虚拟专用网"></a> 2、虚拟专用网</h3><ul><li>虚拟专用网（Virtual Private Network，VPN）利用公用的互联网作为本机构各专用网之间的通信载体。</li><li>如果专用网不同网点之间的通信必须经过互联网，又有保密要求，所有通过互联网传送的数据都必须加密。</li><li>给专用网内各主机配置的IP地址应该是该专用网所在机构可以自行分配的<strong>专用地址</strong>，仅在机构内部有效。</li><li>【RFC 1918】规定了以下三个CIDR地址块中的地址作为专用地址：<ul><li>A类，或记为10.0.0.0/8，它又称为 24 位块：10.0.0.0 到 10.255.255.255‘</li><li>B类，或记为172.16.0.0/12，它又称为 20 位块：172.16.0.0 到 172.31.255.255</li><li>C类，或记为192.168.0.0/16，它又称为 16 位块：192.168.0.0 到 192.168.255.255</li></ul></li><li>“虚拟”表示“好像是”，但实际上并不是，因为<strong>现在并没有真正使用通信专线</strong>，而VPN只是在效果 上和真正的专用网一样。</li><li>IP数据报在因特网中可能要经过多个网络和路由器，但从逻辑上看，路由器R1和R2之间好像是一条直通的点对点链路，因此也被称为IP隧道技术。</li><li>一个机构要构建自己的VPN就必须为它的每一个场所购买专门的硬件和软件，并进行配置，使每一个场所的VPN系统都知道其他场所的地址。<ul><li>内联网（intranet）VPN：同一机构内不同部门的内部网络所构成的虚拟专用网VPN。</li><li>外联网（extranet）VPN：一个机构和某些外部机构共同建立的虚拟专用网VPN。</li><li>远程接入（remote access）VPN：在外地工作的员工需要访问公司内部的专用网时，只要在任何地点接入 因特网，运行驻留在员工PC中的VPN软件，在员工的PC和公司的主机之间建立VPN隧道，就可以访问专 用网中的资源。外地员工与公司通信的内容是保密的，员工们感到好像就是使用公司内部的本地网络。</li></ul></li></ul><h3 id="3-网络地址转换nat"><a class="markdownIt-Anchor" href="#3-网络地址转换nat"></a> 3、网络地址转换NAT</h3><ul><li><p>在专用网上使用专用地址的主机如何与互联网上的主机通信（并不需要加密）？</p><ul><li>再申请一些全球IP地址，但这在很多情况下是不容易做到的。</li><li>采用网络地址转换（Network Address Translation，NAT），这是目前使用得最多的方法。</li></ul></li><li><p>网络地址转换NAT技术于1994年被提出，用来缓解IPv4地址空间即将耗尽的问题。</p><ul><li>NAT能使<strong>大量使用内部专用地址的专用网络用户共享少量外部全球地址</strong>来访问因特网上的主机和资源。</li><li>需要在专用网连接到互联网的<strong>路由器上安装NAT软件（NAT路由器）</strong>，至少有一个有效的外部全球IP地址。</li><li>所有使用本地地址的主机在和外界通信时，都要在NAT路由器上将其<strong>本地地址转换成全球IP地址</strong>，才能和互联网连接。</li></ul></li><li><p>在内部主机与外部主机通信时，在NAT路由器上发生了两次地址转换：</p><ul><li>离开专用网时：替换源地址，将内部地址替换为全球地址；</li><li>进入专用网时：替换目的地址，将全球地址替换为内部地址。</li></ul></li><li><p>通过NAT路由器的通信必须由专用网内的主机发起。</p></li><li><p>专用网内部的主机不能充当服务器用，因为互联网上的客户无法请求专用网内的服务器提供服务。</p></li><li><p>由于目前绝大多数基于TCP/IP协议栈的网络应用，都使用运输层的传输控制协议TCP或用户数据报协议UDP， 为了更加有效地利用NAT路由器中的全球IP地址，现在常将<strong>NAT转换和运输层端口号结合使用</strong>。</p><ul><li>可以使多个拥有本地地址的主机，共用一个NAT路由器上的全球IP地址，可同时和互联网上不同主机通信。</li><li><strong>使用端口号的NAT叫做网络地址与端口号转换NAPT</strong> (Network Address and Port Translation)，而不使用端 口号的NAT就叫做传统的NAT (traditional NAT)。</li><li>现在很多家用路由器将家中各种智能设备（手机、平板、笔记本电脑、台式电脑、物联网设备等）接入互 联网，这种路由器实际上就是一个NAPT路由器，但往往并不运行路由选择协议。</li></ul></li><li><p>NAPT把专用网内不同的源IP地址，都转换为同样的全球IP地址。但<strong>对源主机所采用的TCP端口号（不管相同或不同），则转换为不同的新的端口号</strong>。因此，当NAPT路由器收到从互联网发来的应答时，就可以<strong>从IP数据报的数据部分找出运输层的端口号</strong>，然后根据不同的目的端口号，从NAPT转换表中找到正确的目的主机。</p></li><li><p>尽管NAT和NAPT的出现在很大程度上缓解了IPv4地址资源紧张的局面，但NAT和NAPT对网络应用并不完全透明，会对某些网络应用产生影响。</p></li><li><p><strong>NAT和NAPT的一个重要特点就是通信必须由专用网内部发起</strong>，因此拥有内部专用地址的主机不能直接充当因特网中的服务器。</p></li><li><p>对于目前P2P这类需要外网主机主动与内网主机进行通信的网络应用，在通过NAT时会遇到问题，需要网络应用自身使用一些特殊的NAT穿透技术来解决。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计网</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络第三章 数据链路层</title>
    <link href="/2024/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/"/>
    <url>/2024/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/</url>
    
    <content type="html"><![CDATA[<h2 id="一-数据链路层概述"><a class="markdownIt-Anchor" href="#一-数据链路层概述"></a> 一、数据链路层概述</h2><h3 id="1-数据链路层在网络体系结构中所处的地位"><a class="markdownIt-Anchor" href="#1-数据链路层在网络体系结构中所处的地位"></a> 1、数据链路层在网络体系结构中所处的地位</h3><img src="/2024/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/1.1.png" class=""><h3 id="2-链路-数据链路和帧"><a class="markdownIt-Anchor" href="#2-链路-数据链路和帧"></a> 2、链路、数据链路和帧</h3><ul><li>链路（link）是指从一个节点到相邻节点的一段<strong>物理线路</strong>（有线或无线），而中间没有任何其他的交换节点。</li><li>数据链路（data link）是基于链路的。除需要链路本身，还需要一些必要的通信协议来控制这些数据的传输，把<strong>实现这些协议的硬件和软件加到链路上</strong>，就构成了数据链路。<ul><li>计算机中的网络适配器（俗称网卡）和其相应的软件驱动程序就实现了这些协议。一般的网络适配器都包含了物理层和数据链路层这两层的功能。</li></ul></li><li>帧（frame）是数据链路层对等实体之间在水平方向进行逻辑通信的协议数据单元PDU。</li></ul><h3 id="3-数据链路层使用的两种信道"><a class="markdownIt-Anchor" href="#3-数据链路层使用的两种信道"></a> 3、数据链路层使用的两种信道</h3><ul><li>点对点信道，这种信道使用<strong>一对一</strong>的点对点通信方式。</li><li>广播信道，这种信道使用<strong>一对多</strong>的广播通信方式，必须使用专用的<strong>共享信道协议</strong>来协调这些主机的数据发送。</li></ul><h3 id="4-数据链路层的三个基本问题"><a class="markdownIt-Anchor" href="#4-数据链路层的三个基本问题"></a> 4、数据链路层的三个基本问题</h3><ul><li><p>封装成帧</p><ul><li>封装成帧就是在一段数据的前后分别添加首部和尾部，然后就构成了一个帧。<ul><li>帧的首部和尾部中包含有一些重要的控制信息。</li><li>帧首部和尾部的一个重要作用就是<strong>帧定界</strong>。</li></ul></li><li>控制字符 SOH (Start Of Header) 放在一帧的最前面，表示帧的首部开始。另一个控制字符EOT (End Of Transmission) 表示帧的结束。</li><li>值得注意：并不是每一种数据链路层协议的帧都包含有帧定界标志（以太网帧：利用<strong>帧间隙</strong>和物理层插入的<strong>前导码</strong>）。</li><li>为了提高数据链路层传输帧的效率，应当使帧的数据载荷的长度尽可能地大于首部和尾部的长度。考虑到对缓存空间的需求以及差错控制等诸多因素，每一种数据链路层协议都规定了帧的数据载荷的长度上限，即最大传送单元（Maximum Transfer Unit，MTU）。</li><li>以太网的最大传送单元MTU为1500个字节。</li></ul></li><li><p>透明传输</p><ul><li>如果数据中的某个字节的二进制代码恰好和SOH或EOT一样，数据链路层就会错误地“找到帧的边界” ，把部分帧收下，而把剩下的那部分丢弃。在数据链路层“透明传输”表示无论什么样的比特组合的数据，都能够按照原样没有差错地通过这个数据链路层。数据链路层对这些数据来说是透明的。</li><li><strong>字节填充</strong> (byte stuffing) ，又叫做字符填充 (character stuffing)。<ul><li>发送端的数据链路层在数据中出现控制字符SOH或EOT的前面插入一个<strong>转义字符ESC</strong>。接收端的数据链路层在将数据送往网络层之前删除插入的转义字符。</li><li>转义字符ESC的十六进制编码是 1B，二进制是00011011。</li><li>如果转义字符也出现在数据当中，那么发送端应在转义字符前面插入一个转义字符ESC，当接收端收到连续的两个转义字符时，就删除其中前面的一个。</li></ul></li><li>零比特填充：比特流尚未加上标志字段时，只要发现5个连续1，则立即填入一个0。</li></ul></li><li><p>差错检测</p><ul><li><p>比特在传输过程中可能会产生差错（称为<strong>比特差错</strong>）。一段时间内，传输错误的比特数量占所传输比特总数的比率称为<strong>误码率</strong>（Bit Error Rate，BER）。<strong>提高链路的信噪比</strong>，可以降低误码率。但在实际的通信链路上，不可能使误码率下降为零。</p></li><li><p>奇偶校验</p><ul><li>奇校验是在待发送的数据后面添加1个校验位，使得添加该校验位后的整个数据中比特1的个数为奇数。</li><li>偶校验是在待发送的数据后面添加1个校验位，使得添加该校验位后的整个数据中比特1的个数为偶数。</li><li>如果有偶数个位发生误码，则所包含比特1的数量的奇偶性不会发生改变，无法检测出误码（漏检）。</li></ul></li><li><p>汉明码</p><ul><li><a href="https://blog.csdn.net/a493823882/article/details/109343791">https://blog.csdn.net/a493823882/article/details/109343791</a></li><li>汉明码解决的问题：假设有1位发生改变，汉明码能找到是哪一位发生了改变并纠正它。</li></ul></li><li><p>循环冗余校验</p><ul><li><p>在发送端，先把数据划分为组（假定每组 k 个比特）。若待传送的某一组数据为 M，在 M 的后面再添加供差错检测用的 n 位冗余码一起发送。</p></li><li><p>用二进制的模 2 运算进行 2<sup>n</sup> 乘 M 的运算：这相当于在 M 后面添加 n 个 0。</p></li><li><p>得到的 (k + n) 位的数（被除数）除以事先选定好的长度为 (n + 1) 位的除数 P，得出商是 Q（没用处）而余数是 R，余数 R 比除数 P 少 1 位，即 R 是 n 位。</p></li><li><p>将余数 R 作为冗余码拼接在数据 M 后面发送出去，即发送的数据是：2 <sup>n</sup>M + R，共 (k + n) 位 。在数据后面添加上的冗余码称为帧检验序列 (Frame Check Sequence，FCS )。</p></li><li><p>在接收端，对收到的每一帧进行 CRC 检验：</p><ul><li><p>若得出的余数 R = 0，则判定这个帧没有差错（出现误码的概率非常小），就接受。</p></li><li><p>若得出的余数 R ≠ 0，则判定这个帧有差错，就丢弃。</p></li><li><p>这种检测方法并不能确定究竟是哪一个或哪几个比特出现了差错。</p></li></ul></li><li><p>在数据链路层使用 CRC 检验，能够实现无比特差错的传输，但这还不是可靠传输。</p></li></ul></li></ul></li></ul><h2 id="二-点对点协议ppp"><a class="markdownIt-Anchor" href="#二-点对点协议ppp"></a> 二、点对点协议PPP</h2><h3 id="1-点对点协议ppp概述"><a class="markdownIt-Anchor" href="#1-点对点协议ppp概述"></a> 1、点对点协议PPP概述</h3><ul><li>点对点协议（Point-to-Point Protocol，PPP）是目前使用最广泛的点对点数据链路层协议。</li><li>点对点协议PPP应满足的要求：<ul><li>简单 —— 这是首要的要求。</li><li>封装成帧 —— 必须规定特殊的字符作为帧定界符。</li><li>透明性 —— 必须保证数据传输的透明性。</li><li>多种网络层协议 —— 必须能够在同一条物理链路上同时支持多种网络层协议。</li><li>多种类型链路 ——必须能够在多种类型的链路上运行（串行/并行、同步/异步、低速/高速、光/电链路等）。</li><li>差错检测 ——必须能够对接收端收到的帧进行检测，并立即丢弃有差错的帧。</li><li>检测连接状态 ——必须能够及时自动检测出链路是否处于正常工作状态。</li><li>最大传送单元 —— 必须对每一种类型的点对点链路设置最大传送单元MTU的标准默认值，促进互操作性。MTU是数据链路层的帧可以载荷的数据部分的最大长度，而不是帧的总长度。</li><li>网络层地址协商 —— 必须提供一种机制使通信的两个网络层实体能够通过协商知道或能够配置彼此的网络层地址，协商算法尽可能简单。</li><li>数据压缩协商 —— 必须提供一种方法来协商使用数据压缩算法，但不要求将数据压缩算法进行标准化。</li></ul></li><li>PPP 协议有三个组成部分：<ul><li>一个将 IP 数据报封装到串行链路的方法。</li><li>一个用来建立、配置和测试数据链路连接的链路控制协议 LCP (Link Control Protocol)。</li><li>一套支持不同网络层协议的网络控制协议 NCP (Network Control Protocol)。</li></ul></li></ul><h3 id="2-ppp协议的帧格式"><a class="markdownIt-Anchor" href="#2-ppp协议的帧格式"></a> 2、PPP协议的帧格式</h3><ul><li><p>封装成帧</p><img src="/2024/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/PPP%E5%B8%A7%E6%A0%BC%E5%BC%8F.png" class=""><ul><li>标志（Flag）字段：PPP帧的定界符，取值为0x7E。</li><li>地址（Address）字段：取值为0xFF。</li><li>控制（Control）字段：取值为0x03。</li><li>协议（Protocol）字段：其值用来指明帧的数据载荷应向上交付给哪个协议处理。</li><li>帧检验序列（Frame Check Sequence，FCS）字段：其值是使用循环冗余校验CRC计算出的检错码。</li></ul></li><li><p>透明传输</p><ul><li><p><strong>面向字节的异步链路</strong>使用<strong>字节填充</strong>来实现透明传输。</p><ul><li><p>发送方的处理：</p><ol><li>将数据载荷中出现的每一个0x7E减去0x20（相当于异或0x20），然后在其前面插入转义字符0x7D。</li><li>若数据载荷中原来就含有0x7D，则把每一个0x7D减去0x20，然后在其前面插入转义字符0x7D。</li><li>将数据载荷中出现的每一个ASCII码控制字符（即数值小于0x20的字符），加上0x20（相当于异或0x20，将其转换成非控制字符），然后在其前面插入转义字符0x7D。</li></ol></li><li><p>接收方的处理：</p><p>进行与发送方相反的变换，就可以正确地恢复出未经过字节填充的原始数据载荷。</p></li></ul></li><li><p><strong>面向比特的同步链路</strong>使用<strong>零比特填充</strong>来实现透明传输。</p><ul><li><p>发送方的处理：</p><p>对帧的数据载荷进行扫描（一般由硬件完成），每出现5个连续的比特1，则在其后填充一个比特0。</p></li><li><p>接收方的处理：</p><p>对帧的数据载荷进行扫描，每出现5个连续的比特1时，就把其后的一个比特0删除。</p></li></ul></li></ul></li><li><p>差错检测</p><ul><li>使用PPP协议的数据链路层，向上提供的是不可靠数据传输服务。</li><li>PPP 协议不使用序号和确认的可靠传输机制是出于以下的考虑：<ul><li>帧检验序列 FCS 字段可保证无差错接受。</li><li>在数据链路层出现差错的概率不大时，使用比较简单的 PPP 协议较为合理。</li><li>互联网环境，PPP信息字段放入的是IP数据报，数据链路层的可靠传输并不能够保证网络层的可靠传输。</li></ul></li></ul></li></ul><h2 id="三-使用广播信道的数据链路层"><a class="markdownIt-Anchor" href="#三-使用广播信道的数据链路层"></a> 三、使用广播信道的数据链路层</h2><h3 id="1-局域网"><a class="markdownIt-Anchor" href="#1-局域网"></a> 1、局域网</h3><ul><li>局域网最主要的特点：网络为一个单位所拥有，地理范围和站点数目均有限。</li><li>局域网最主要的优点：<ul><li>具有广播功能，从一个站点可很方便地访问全网，共享连接在局域网上的硬件和软件资源。</li><li>便于系统的扩展和逐渐地演变，各设备的位置可灵活调整和改变。</li><li>提高了系统的可靠性、可用性和生存性。</li></ul></li><li>局域网的拓扑结构：<ul><li>星形网</li><li>环形网</li><li>总线网</li></ul></li></ul><h3 id="2-以太网"><a class="markdownIt-Anchor" href="#2-以太网"></a> 2、以太网</h3><ul><li>严格说来， “以太网”应当是指符合 DIX Ethernet V2 标准的局域网 。</li><li>IEEE 802 委员会将局域网的数据链路层拆成两个子层（更好地适应多种局域网标准）：<ul><li>逻辑链路控制 LLC（Logical Link Control）子层</li><li>媒体接入控制 MAC（Medium Access Control）子层</li></ul></li><li>与接入到传输媒体有关的内容都放在 MAC子层，局域网对 LLC 子层是透明的。</li><li>由于 TCP/IP 体系经常使用的局域网是 DIX Ethernet V2，LLC的作用已经消失，本章只考虑MAC层。</li></ul><h3 id="3-网络适配器"><a class="markdownIt-Anchor" href="#3-网络适配器"></a> 3、网络适配器</h3><ul><li>要将计算机连接到以太网，需要使用相应的网络适配器（Adapter），网络适配器又称为网络接口卡（Network Interface Card，NIC），简称为“网卡” 。</li><li>在计算机内，适配器与CPU之间的通信，一般通过计算机主板上的I/O总线以<strong>并行传输</strong>方式进行。</li><li>适配器与外部以太网（局域网）之间的通信，一般是通过传输媒体以<strong>串行</strong>方式进行的。</li><li>适配器除要实现物理层和数据链路层功能，还要进行数据并行传输和串行传输的转换。</li><li>由于网络的传输速率和计算机内部总线上的传输速率并不相同，因此在适配器中必须包含用于缓存数据的存储器。</li><li>在网卡硬件正确情况下，还要在操作系统中为安装相应的驱动程序，负责驱动网卡发送和接收帧。</li><li>注意：计算机的硬件地址（MAC地址）就在适配器的ROM中； 而计算机的软件地址（IP地址）则在计算机的存储器中。<img src="/2024/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/3-15.png" class=""></li></ul><h3 id="4-以太网的mac层"><a class="markdownIt-Anchor" href="#4-以太网的mac层"></a> 4、以太网的MAC层</h3><ul><li>MAC地址<ul><li>当多个主机连接在同一个广播信道上，要想实现两个主机之间的通信，则<strong>每个主机都必须有一个唯一的标识</strong>，即一个数据链路层地址。由于这类地址是用于媒体接入控制（Medium Access Control，MAC）的，因此被称为MAC地址。</li><li>MAC地址一般被固化在网络适配器（网卡）的电可擦可编程只读存储器EEPROM中，因此MAC地址也被称为<strong>硬件地址</strong>或<strong>物理地址</strong>，即适配器标识符。</li><li>一般情况下，普通用户计算机中往往会包含两块网卡：<ul><li>一块是用于接入有线局域网的以太网卡</li><li>另一块是用于接入无线局域网的Wi-Fi网卡</li></ul></li><li>每块网卡都有一个全球唯一的MAC地址。</li><li>交换机和路由器往往具有更多的网络接口，所以会拥有更多的MAC地址。</li><li>严格来说，MAC地址是对网络上各接口的唯一标识，而不是对网络上各设备的唯一标识。</li><li><img src="/2024/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/MAC%E5%9C%B0%E5%9D%80%E6%A0%BC%E5%BC%8F.png" class=""></li><li>IEEE 规定地址字段的第一字节的最低位为 I/G 位。<ul><li>当I/G位=0时，表示一个单播/单站地址。（第二个十六进制数为偶数）</li><li>当I/G位=1时，表示多播/组地址。 （第二个十六进制数为奇数）</li><li>当 I/G 位分别为 0 和 1 时，一个地址块可分别生成 2<sup>23</sup>个单播地址和 2<sup>23</sup>个多播地址。</li></ul></li><li><strong>广播地址：所有 48 位都为 1</strong> 时（FF-FF-FF-FF-FF-FF），只能作为目的地址使用。</li><li>IEEE规定地址字段的第一字节的第2低位为 G/L 位。<ul><li>当G/L位=0时，是全球管理地址，保证在全球没有相同的地址。厂商向IEEE购买的 OUI 都属于全球管理。</li><li>当G/L位=1时， 是本地管理地址，这时用户可任意分配网络上的地址。</li></ul></li><li>适配器具有“过滤功能” ，每收到一个 MAC 帧就首先用硬件检查 MAC 帧中的 MAC 地址。如果是发往本站的帧，则收下，然后再进行其他的处理，否则丢弃。</li><li>IEEE 802局域网的MAC地址发送顺序：<strong>按照字节顺序，低位先发送</strong></li><li>“发往本站的帧”包括以下三种帧：<ul><li>单播 (unicast) 帧（一对一）：收到的帧的MAC地址与本站的MAC地址相同。</li><li>广播 (broadcast) 帧（一对全体）：发送给本局域网上所有站点的帧（全1地址）。</li><li>多播 (multicast) 帧（一对多）：发送给本局域网上一部分站点的帧。</li></ul></li><li>网卡从网络上每收到一个帧，就检查帧首部中的目的MAC地址，按以下情况处理：<ul><li>如果目的MAC地址是广播地址（FF-FF-FF-FF-FF-FF），则接受该帧。</li><li>果目的MAC地址与网卡上固化的全球单播MAC地址相同，则接受该帧。</li><li>如果目的MAC地址是网卡支持的多播地址，则接受该帧。</li></ul></li><li>网卡还可被设置为一种特殊的工作方式：混杂方式（Promiscuous Mode），只要收到共享媒体上传来的帧就会收下，而不管帧的目的MAC地址是什么。</li></ul></li><li>MAC帧格式<ul><li><img src="/2024/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/MAC%E5%B8%A7%E6%A0%BC%E5%BC%8F.png" class=""></li><li>目的地址和源地址用来填入帧的目的MAC地址和源MAC地址。</li><li>类型用来指明数据载荷中的内容是由上一层的哪个协议封装的，以便将收到的MAC帧的数据载荷上交给上一层的这个协议。</li><li>使用CRC生成的帧检验序列FCS，接收方的网卡通过FCS的内容就可检测出帧在传输过程中是否产生了误码。检验范围为目的地址、源地址、类型和数据载荷。</li><li>以太网 MAC 帧满足最小帧长为64B的要求：6B + 6B + 2B + 46B + 4B = 64B。<ul><li>当数据字段的长度小于 46 字节时，应在数据字段的后面加入整数字节的填充字段。</li></ul></li><li>以太网 MAC 帧<strong>数据字段</strong>的最大长度被限制为1500B。</li><li>为了达到比特同步，在传输媒体上实际传送的要比 MAC 帧还多 8 个字节。<ul><li>在帧的前面插入（硬件生成）的 8 字节。</li><li>第一个字段 7 个字节，是前同步码（1和0交替码），用来迅速实现 MAC 帧的比特同步。</li><li>第二个字段 1 个字节是帧开始定界符（10101011），表示后面的信息就是 MAC 帧。</li></ul></li><li>无效的MAC帧<ul><li>帧的长度不是整数个字节。</li><li>数据字段的长度与长度字段的值不一致。</li><li>数据字段的长度不在 46 ~ 1500 字节之间。</li><li>用收到的帧检验序列 FCS 查出有差错。</li></ul></li><li>有效的MAC帧长度为 64 ~ 1518 字节之间。</li><li>网络适配器对于检查出的无效 MAC 帧就简单地丢弃，以太网不负责重传丢弃的帧。</li><li>IEEE 802.3规定的 MAC 帧的第三个字段是“长度 / 类型”。</li><li>当这个字段值大于 0x0600 时（相当于十进制的1536），就表示“类型”。这样的帧和以太网V2 MAC 帧完全一样。</li><li>当这个字段值小于 0x0600 时，就表示“长度”，即帧数据字段的长度，数据字段必须装入上面的逻辑链路控制 LLC 子层的 LLC 帧。</li></ul></li></ul><h3 id="5-csmacd协议"><a class="markdownIt-Anchor" href="#5-csmacd协议"></a> 5、CSMA/CD协议</h3><ul><li>基本原理<ul><li>共享总线以太网的特点：广播特性，即使总线上某个站点给另一个站点发送单播帧，表示帧的信号也会沿着总线传播到总线上的其他各站点。</li><li>当某个站点在总线上发送帧时，总线资源会被该站点独占。此时，如果总线上的其他站点也要在总线上发送帧，就会产生信号碰撞。</li><li>为了通信的简便，以太网采取了两种重要的措施：<ul><li>采用较为灵活的无连接的工作方式<ul><li>不必先建立连接就可以直接发送数据。</li><li>对发送的数据帧不进行编号，也不要求对方发回确认。（局域网信道质量好，差错概率很小）</li><li>以太网提供的服务是<strong>不可靠的交付</strong>，即尽最大努力的交付。</li><li>差错的纠正由高层来决定，当收到有差错的数据帧时就丢弃此帧，其他什么也不做。</li><li>以太网并不知道重传的帧，而是当作一个新的数据帧来发送。</li><li><strong>由于共享总线，在同一时间只能允许同一台主机发送数据。</strong></li></ul></li><li>以太网发送的数据都使用<strong>曼彻斯特 (Manchester) 编码</strong><ul><li>曼彻斯特编码具有自同步能力。</li><li><strong>曼彻斯特编码所占的频带宽度比原始的基带信号增加了一倍。</strong>（每秒传送的码元数加倍了）</li></ul></li></ul></li><li>为了解决各站点争用总线的问题，共享总线以太网使用了一种专用协议CSMA/CD，它是载波监听/多址接入/碰撞检测（Carrier Sense Multiple Access/Collision Detection）的英文缩写词。</li><li>载波监听CS<ul><li>每个站点在发送帧之前，先要检测一下总线上是否有其他站点在发送帧（先听后说）：<ul><li>若检测到总线空闲时，则发送这个帧；</li><li>若检测到总线忙，则继续检测并等待总线转为空闲，然后发送这个帧。</li></ul></li><li><strong>帧间最小间隔为 9.6 𝝁s</strong>，<strong>相当于 96 bit 的发送时间</strong>。一个站在检测到总线开始空闲后，还要等待 9.6 𝝁s 才能再次发送数据，这样做是为了使刚刚收到数据帧的站的接收缓存来得及清理，做好接收下一帧的准备。</li></ul></li><li>多址接入MA<ul><li>多个站点连接在一条总线上，竞争使用总线。</li></ul></li><li>碰撞检测CD<ul><li>每个正在发送帧的站点边发送边检测碰撞（边说边听）：<ul><li>一旦发现总线上出现碰撞，立即停止发送，退避一段随机时间再次从载波监听开始进行发送。</li></ul></li><li>发送帧的站点一旦检测到碰撞，除了立即停止发送帧外，还要再继续发送<strong>32比特或48比特的人为干扰信号</strong> （Jamming Signal），以便有足够多的碰撞信号使所有站点都能检测出碰撞 。</li></ul></li></ul></li><li>几点重要说明<ul><li>电磁波在总线上的传播速率是有限的，当某个站监听到总线是空闲时，总线可能并非真正空闲。</li><li>“碰撞检测”就是计算机边发送数据边检测信道上的<strong>信号电压大小</strong>。<ul><li>当几个站同时在总线上发送数据时，总线上的信号电压摆动值将会增大（互相叠加）。</li><li>所谓“碰撞”就是发生了冲突。因此“碰撞检测”也称为“冲突检测” 。</li></ul></li><li>使用CSMA/CD协议的共享总线以太网上的各站点，只是尽量避免碰撞并在出现碰撞时做出退避后重发的处理，但不能完全避免碰撞。这种发送的不确定性使整个以太网的平均通信量远小于以太网的最高数据率。</li><li>在使用CSMA/CD协议时，必须“边发送边检测碰撞” ，只能进行<strong>半双工通信</strong>（双向交替通信）。</li></ul></li><li>争用期<ul><li><img src="/2024/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/%E4%BA%89%E7%94%A8%E6%9C%9F.png" class=""></li><li>站点从发送帧开始，最多经过时长 𝟐𝝉（即𝜹→𝟎）就可检测出所发送的帧是否遭遇了碰撞。</li><li>端到端往返时间 𝟐𝝉 被称为争用期（Contention Period）或碰撞窗口（Collision Window）。<ul><li>从发送帧开始，经过争用期 𝟐𝝉 时间还没有检测到碰撞，就可以肯定这次发送不会产生碰撞。</li></ul></li><li>每一个站点从发送帧开始，到之后的一小段时间内，都有可能遭遇碰撞，而这一小段时间取决于<strong>另一个发送帧的站点与本站点的距离</strong>，但不会超过总线的端到端往返传播时延，即一个争用期𝟐𝝉。<ul><li>总线的长度越长（单程端到端传播时延越大），网络中站点数量越多，发生碰撞概率就越大。</li><li>共享以太网的总线长度不能太长，接入的站点数量也不能太多。</li></ul></li><li><strong>𝟏𝟎 Mbit/s 总线以太网</strong>（<strong>传统以太网</strong>）规定：争用期 𝟐𝝉 的值为 <strong>𝟓𝟏𝟐 比特的发送时间</strong>，即𝟓𝟏.𝟐𝝁s 。</li><li>以太网在发送数据时，若前 𝟓𝟏𝟐 比特（64 字节）没有发生冲突，则后续的数据就不会发生冲突。</li><li>以太网规定最短有效帧长为 64 字节，凡长度小于 64 字节的帧都是由于冲突而异常中止的无效帧。</li><li>最小帧长 = 数据传输速率 × 争用期</li></ul></li><li>退避算法<ul><li>退避时间=争用期 × 随机数r<ul><li>𝒓从离散的整数集合{𝟎, 𝟏, … , (𝟐 𝒌 − 𝟏)}中<strong>随机选出</strong>一个数，𝒌 = min[重传次数，𝟏𝟎]</li></ul></li><li>如果连续多次发送碰撞，就表明可能有较多的站点参与竞争信道。但使用上述退避算法可使重传需要推迟的平均时间随重传次数而增大（即动态退避），因而减小产生碰撞的概率。</li><li>当重传达16次仍不能成功时，就表明同时打算发送帧的站点太多，以至于连续产生碰撞，此时应丢弃该帧，放弃重传，并向高层报告。</li></ul></li></ul><h3 id="6-以太网的信道利用率"><a class="markdownIt-Anchor" href="#6-以太网的信道利用率"></a> 6、以太网的信道利用率</h3><ul><li><p>一个站在发送帧时出现了碰撞。经过一个争用期 𝟐𝝉 后，可能又出现了碰撞。这样经过若干个争用期后，一个站发送成功了。假定发送帧需要的时间是 T<sub>0</sub>。</p></li><li><p>成功发送一个帧需要占用信道的时间是 T<sub>0</sub> + 𝝉，比这个帧的发送时间要多一个单程端到端时延 𝝉。</p><ul><li>这是因为当一个站发送完最后一个比特时，这个比特还要在以太网上传播。</li><li>在最极端的情况下，比特在媒体上传输到另一端所需的时间是 𝝉。</li></ul></li><li><p>考虑以下这种理想情况：</p><ul><li><p>总线一旦空闲就有某个站点立即发送帧</p></li><li><p>各站点发送帧都不会产生碰撞</p></li><li><p>发送一帧占用总线的时间为 T<sub>0</sub>+ 𝝉，而帧本身的发送时间是 T<sub>0</sub></p><p>极限信道利用率 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>S</mi><mrow><mi>m</mi><mi>a</mi><mi>x</mi></mrow></msub><mo>=</mo><mfrac><msub><mi>T</mi><mn>0</mn></msub><mrow><msub><mi>T</mi><mn>0</mn></msub><mo>+</mo><mi>τ</mi></mrow></mfrac><mo>=</mo><mfrac><mn>1</mn><mrow><mn>1</mn><mo>+</mo><mfrac><mi>τ</mi><msub><mi>T</mi><mn>0</mn></msub></mfrac></mrow></mfrac><mo>=</mo><mfrac><mn>1</mn><mrow><mn>1</mn><mo>+</mo><mi>a</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">S_{max}=\frac{T_0}{T_0+\tau}=\frac{1}{1+\frac{\tau}{T_0}}=\frac{1}{1+a}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.3335309999999998em;vertical-align:-0.44509999999999994em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8884309999999999em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31731428571428577em;"><span style="top:-2.357em;margin-left:-0.13889em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mbin mtight">+</span><span class="mord mathnormal mtight" style="margin-right:0.1132em;">τ</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.4101em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31731428571428577em;"><span style="top:-2.357em;margin-left:-0.13889em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.44509999999999994em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.580728em;vertical-align:-0.7356199999999999em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mbin mtight">+</span><span class="mord mtight"><span class="mopen nulldelimiter sizing reset-size3 size6"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6915428571428572em;"><span style="top:-2.656em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3447999999999998em;margin-left:-0.13889em;margin-right:0.1em;"><span class="pstrut" style="height:2.64444em;"></span><span class="mord mtight">0</span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29964em;"><span></span></span></span></span></span></span></span></span></span><span style="top:-3.2255000000000003em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line mtight" style="border-bottom-width:0.049em;"></span></span><span style="top:-3.384em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.1132em;">τ</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.5580285714285714em;"><span></span></span></span></span></span><span class="mclose nulldelimiter sizing reset-size3 size6"></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.7356199999999999em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.2484389999999999em;vertical-align:-0.403331em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mbin mtight">+</span><span class="mord mathnormal mtight">a</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.403331em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></p></li></ul></li><li><p>要提高以太网的信道利用率，就必须减小 𝝉 与 T0 之比，即参数 𝒂 。</p></li><li><p>对以太网参数 𝒂 的要求是：</p><ul><li>当数据率一定时，以太网的连线的长度受到限制，否则 𝒂 的数值会太大。</li><li>以太网的帧长不能太短，否则 T<sub>0</sub> 的值会太小，使 𝒂 值太大。</li></ul></li></ul><h2 id="四-扩展的以太网"><a class="markdownIt-Anchor" href="#四-扩展的以太网"></a> 四、扩展的以太网</h2><h3 id="1-共享式以太网"><a class="markdownIt-Anchor" href="#1-共享式以太网"></a> 1、共享式以太网</h3><ul><li>使用同轴电缆的共享式以太网<ul><li>早期的传统以太网使用粗同轴电缆的共享总线以太网，后来发展到使用价格相对便宜的细同轴电缆。</li><li>若总线上的某个机械连接点接触不良或断开，则整个网络通信就不稳定或彻底断网。</li></ul></li><li>使用集线器的共享式以太网<ul><li>在使用细同轴电缆的共享总线以太网之后，以太网发展出来了一种使用大规模集成电路来替代总线、并且可靠性非常高的设备，叫作集线器（hub）。站点连接到集线器的传输媒体也转而使用更便宜、更灵活的双绞线电缆。</li><li>集线器的一些主要特点如下：<ul><li>使用集线器虽然<strong>物理拓扑是星型的</strong>，但在<strong>逻辑上仍然是总线网</strong>。各站点共享总线资源，使用CSMA/CD协议。</li><li><strong>集线器只工作在物理层</strong>，每个接口仅简单地转发比特，并不进行碰撞检测。碰撞检测由各站点中的网卡负责。</li><li>集线器采用了专门的芯片，进行自适应串音回波抵消，减少了近端串音。</li><li>集线器一般都有少量的容错能力和网络管理功能。例如，若网络中某个站点的网卡出现了故障而不停地发送帧，集线器可以检测到这个问题，在内部断开与出故障网卡的连线，使整个以太网能正常工作。</li></ul></li><li>10BASE-T以太网的通信距离较短，每个站点到集线器的距离不能超过100m。</li></ul></li></ul><h3 id="2-在物理层扩展以太网"><a class="markdownIt-Anchor" href="#2-在物理层扩展以太网"></a> 2、在物理层扩展以太网</h3><ul><li>扩展站点与集线器之间的距离<ul><li>共享总线以太网中两站点距离不能太远，所传输的信号会衰减到使CSMA/CD协议无法正常工作。</li><li>在早期广泛使用粗同轴电缆或细同轴电缆共享总线以太网时，为了提高网络的地理覆盖范围，常用的是工作在物理层的转发器。</li><li>IEEE 802.3 标准规定，两个网段可用一个转发器连接，任意两个站点之间最多可以经过三个网段。</li><li>10BASE-T星型以太网中每个站点到集线器的距离不能超过100m，因此两站点间的通信距离最大不 能超过200m。</li><li>在10BASE-T星型以太网中，可使用光纤和一对光纤调制解调器来扩展站点与集线器之间的距离。</li><li>这种扩展方法比较简单，所需付出的代价是：为站点和集线器各增加一个用于电信号和光信号转换的光纤调制解调器，以及它们之间的一对通信光纤。</li><li>信号在光纤中的衰减和失真很小，这种方法可简单地将站点与集线器之间的距离扩展到1000m以上。</li></ul></li><li>扩展以太网覆盖范围和站点数量<ul><li>以太网集线器一般具有8~32个接口，如果要连接的站点数量超过了单个集线器能够提供的接口数量，就需要<strong>使用多个集线器</strong>，这样就可以连接成覆盖更大范围、连接更多站点的<strong>多级星型以太网</strong>。</li><li>扩大了以太网覆盖的地理范围，使原来属于不同碰撞域的以太网上的站点能够进行跨碰撞域的通信。</li><li>碰撞域（collision domain），又称冲突域，在任一时刻，在每一个碰撞域中只能有一个站在发送数据。广播域（broadcast domain）是网络中一组相互接收广播信息的设备。</li><li>在物理层扩展的共享式以太网仍然是一个碰撞域，不能连接太多的站点。否则出现大量的碰撞。</li><li>碰撞域增大了，但总的吞吐量并未提高。</li><li>如果不同的碰撞域使用不同的数据率，那么就不能用集线器将它们互连起来。</li></ul></li></ul><h3 id="3-在数据链路层扩展以太网"><a class="markdownIt-Anchor" href="#3-在数据链路层扩展以太网"></a> 3、在数据链路层扩展以太网</h3><ul><li>早期使用网桥（bridge），现在使用以太网交换机（switch）。</li><li>网桥工作在数据链路层（包含其下的物理层），因此网桥具备属于数据链路层范畴的相关能力。<ul><li>网桥可以识别帧的结构。</li><li>网桥可以根据帧首部中的目的MAC地址和网桥自身的帧转发表来转发或丢弃（过滤）收到的帧。</li></ul></li><li>网桥的接口在向其连接的网段转发帧时，会执行相应的媒体接入控制协议，对于共享式以太网就是CSMA/CD协议。</li><li>网桥的接口数量很少，通常只有2~4个，一般只用来连接不同的网段。</li><li>交换式集线器（switching hub）实质上是具有多个接口的网桥，常称为以太网交换机或二层交换机。<ul><li>“二层”是指以太网交换机工作在数据链路层（包括物理层）。</li><li>通常都有十几个或更多的接口，每个接口都直接与一个单台主机或另一个以太网交换机相连，并且一般都工作在<strong>全双工方式</strong>。</li><li>有并行性，同时连通多对接口，使多对主机同时通信（网桥只能一次一帧），相互通信的主机都是独占传输媒体，无碰撞地传输数据。</li><li>使用了专用的交换结构芯片，用硬件转发，其转发速率要比使用软件转发的网桥快很多。</li></ul></li><li>用户独享带宽，增加了总容量。<ul><li>对于普通 10 Mbit/s 的共享式以太网，若共有 N 个用户，则每个用户占有的平均带宽只有总带宽 (10 Mbit/s)的 N 分之一。</li><li>使用以太网交换机时，虽然在每个接口到主机的带宽还是 10 Mbit/s，但由于一个用户在通信时是独占而不是和其他网络用户共享传输媒体的带宽，因此对于拥有 N 个接口的交换机的总容量为 N×10 Mbit/s。</li></ul></li><li>以太网交换机的交换方式<ul><li>存储转发方式：把整个数据帧先缓存后再进行处理。</li><li>直通 (cut-through)交换方式：接收数据帧的同时，<strong>不缓存、不检查差错</strong>，就立即按数据帧的目的 MAC地址决定该帧的转发接口，基于<strong>硬件的交叉矩阵</strong>进行转发，提高了帧的转发速度。</li></ul></li><li>交换机的每个接口可以连接计算机，也可以连接集线器或另一个交换机。<ul><li>当交换机的接口与<strong>计算机或交换机</strong>连接时，可以工作在<strong>全双工方式</strong>，并能在自身内部同时连通多对接口，使每一对相互通信的计算机都能像独占传输媒体那样，无碰撞地传输数据，<strong>不需要使用CSMA/CD协议</strong>。</li><li>当交换机的接口与<strong>集线器</strong>连接时，只能使用CSMA/CD协议，并只能工作在<strong>半双工方式</strong>。</li></ul></li><li><strong>仅使用交换机（而不使用集线器）的以太网就是交换式以太网</strong>。</li><li><strong>交换式以太网中的所有站点都属于同一个广播域</strong>。<strong>（交换机隔离冲突域，路由器隔离广播域）</strong></li></ul><h3 id="4-透明网桥以太网交换机的自学习和转发帧的流程"><a class="markdownIt-Anchor" href="#4-透明网桥以太网交换机的自学习和转发帧的流程"></a> 4、透明网桥/以太网交换机的自学习和转发帧的流程</h3><ul><li>透明网桥（transparent bridge）中的“透明”，是指以太网中的各站点并不知道自己所发送的帧将会经过哪些网桥的转发，最终到达目的站点。</li><li>透明网桥/交换机通过一种自学习算法，基于以太网中各站点间的通信逐步建立起自己的转发表。<ul><li>收到帧后进行<strong>登记</strong>（即<strong>自学习</strong>），登记的内容为<strong>帧的源MAC地址</strong>和进入网桥/交换机<strong>接口号</strong>。（若已经存在项目，则更新项目的有效时间）</li><li>根据帧的目的MAC地址和转发表对帧进行转发，包含以下三种情况：<ul><li>盲目转发：只能将其通过除进入接口外的其他所有接口转发。</li><li>明确转发：知道应当从哪个接口转发帧（按交换表中给出的接口）。</li><li>丢 弃：知道不该转发该帧（交换表中给出的接口就是该帧进入的接口），将其丢弃。</li></ul></li><li>如果收到有误码的帧则直接丢弃。</li><li>如果收到一个无误码的广播帧，则不用进行查表，而是直接从除接收该广播帧的接口的其他接口转发该广播帧。</li><li>考虑到有时可能要在交换机端口更换主机，或者主机更换网络适配器，需要及时更改交换表中的项目。为此，当交换表写入一个项目时，就记下当时的时间，超过预先设定的时间就会删除。</li></ul></li></ul><h3 id="5-生成树协议stp"><a class="markdownIt-Anchor" href="#5-生成树协议stp"></a> 5、生成树协议STP</h3><ul><li>为了提高<strong>以太网的可靠性</strong>，有时需要增加一些冗余的链路。</li><li>IEEE 802.1d 标准制定了一个生成树协议 STP (Spanning Tree Protocol)，可以在增加冗余链路提高网络可靠性的同时，又避免环路带来的问题。<ul><li>找出原网络拓扑的一个连通子集，即生成树（不改变网络的实际拓扑，在逻辑上则切断某些链路，使得从一台主机到所有其他主机的路径是无环路树状结构，从而消除了兜圈子现象）。</li><li>生成树状逻辑拓扑确保连同整个网络。</li><li>当首次连接或网络拓扑发生变化时，都会重新构造生成树，以确保网络的连通。</li></ul></li></ul><h3 id="6-虚拟局域网"><a class="markdownIt-Anchor" href="#6-虚拟局域网"></a> 6、虚拟局域网</h3><ul><li>巨大的广播域会带来一系列问题。<ul><li>广播风暴：浪费网络资源和各主机的CPU资源，引起性能恶化。</li><li>难以管理和维护，带来潜在的安全问题。</li></ul></li><li>分割广播域的方法：<ul><li>使用路由器可以隔离广播域（成本较高）。</li><li>使用以太网交换机构建虚拟局域网（Virtual Local Area Network，VLAN）。</li></ul></li><li>虚拟局域网VLAN是一种将局域网内的站点划分成<strong>与物理位置无关的逻辑组的技术</strong>，一个逻辑组就是一个VLAN，VLAN中的各站点具有某些共同的应用需求。<ul><li>每一个VLAN的帧都有一个明确的标识符，指明发送这个帧的计算机属于哪一个VLAN。</li><li>属于同一VLAN的站点之间可以直接进行通信，而不同VLAN中的站点之间不能直接通信。</li><li>网络管理员可对局域网中的各交换机进行配置来建立多个逻辑上独立的VLAN。</li><li>连接在同一交换机上的多个站点可以属于不同的VLAN，而属于同一VLAN的多个站点可以 连接在不同的交换机上。</li></ul></li><li>实现虚拟局域网VLAN最常见的就是基于以太网交换机的接口来实现VLAN，这要求交换机：<ul><li>能够处理带有VLAN标记的帧，也就是IEEE 802.1Q帧。</li><li>交换机的各接口可以支持不同的接口类型，不同接口类型的接口对帧的处理方式有所不同。</li></ul></li><li>IEEE 802.1Q帧对以太网V2的MAC帧进行了扩展：在源地址字段和类型字段间插入4字节的VLAN标签（tag）字段。<img src="/2024/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/VLAN.png" class=""><ul><li>标签协议标识符TPID：长度为16比特，其值固定为0x8100，表示该帧是IEEE 802.1Q帧。</li><li>优先级PRI：长度为3比特，取值是0~7，值越大优先级越高。当网络阻塞时，设备优先发送优先级高的802.1Q帧。</li><li>VLAN标识符VID：长度为12比特，取值范围是0~4095，其中0和4095保留不使用。VID是802.1Q帧所属VLAN的编号，<strong>设备利用VID来识别帧所属的VLAN</strong>。广播帧只在同一VLAN内转发，这样就将广播域限制在了一个VLAN内。</li><li>插入VLAN标签后，802.1Q帧最后的帧检验序列FCS必须重新计算。</li></ul></li><li>802.1Q帧一般不由用户主机处理，而是由以太网交换机来处理<ul><li>当交换机收到普通的以太网MAC帧时，会给其插入4字节的VLAN标签使之成为802.1Q帧，该处理简称为“打标签” 。</li><li>当交换机转发802.1Q帧时，可能会删除其4字节的VLAN标签使之成为普通的以太网MAC帧，该处理简称为“去标签” 。交换机转发802.1Q帧时也有可能不进行“去标签”处理，是否进行“去标签”处理取决于交换机的接口类型。</li></ul></li><li>以太网交换机的接口类型一般分为Access和Trunk两种。<ul><li>Access接口一般用于连接用户计算机，由于其只能属于一个VLAN，因此Access接口的PVID值与其所属VLAN的ID相同，其默认值为1。<ul><li>一般只接受“未打标签”的普通以太网MAC帧，根据接收帧的接口的PVID给帧“打标签”，即插入4字节的VLAN标签字段，VLAN标签字段中的VID取值就是接口的PVID值。</li><li>若帧中的VID值与接口的PVID值相等，则给帧“去标签”后再进行转发，否则不转发帧。因此，<strong>从Access接口转发出的帧，是不带VLAN标签的普通以太网MAC帧</strong>。</li></ul></li><li>Trunk接口一般用于交换机之间的互连。Trunk接口可以属于多个VLAN，即Trunk接口可以通过属于不同VLAN的帧。Trunk接口的默认PVID值为1，一般不建议用户修改，若互连的Trunk接口的PVID值不相等，则可能出现转发错误。<ul><li>既可以接收“未打标签”的普通以太网MAC帧，也可以接收“已打标签”的802.1Q帧。若接收到普通以太网MAC帧时，根据接收帧的接口的PVID给帧“打标签”，这与Access接口的处理相同。</li><li>对于帧的VID值等于接口的PVID值的802.1Q帧，将其“去标签”转发；对于帧的VID值不等于接口的PVID值802.1Q帧，将其直接转发。因此，<strong>从 Trunk接口转发出的帧，可能是普通以太网MAC帧，也可能是802.1Q帧</strong>。</li></ul></li><li>以太网交换机上电启动后，若之前未对其各接口进行过VLAN的相关设置，则各接口的类型默认为Access，并且各接口的缺省VLAN ID为1，即各接口默认属于VLAN1。</li></ul></li><li>每台计算机通过接入链路连接到交换机；交换机接口之间的链路称为汇聚链路或干线链路。</li></ul><h2 id="五-高速以太网"><a class="markdownIt-Anchor" href="#五-高速以太网"></a> 五、高速以太网</h2><h3 id="1-100base-t以太网"><a class="markdownIt-Anchor" href="#1-100base-t以太网"></a> 1、100BASE-T以太网</h3><ul><li>100BASE-T是指在双绞线上传输基带信号的速率为100Mbit/s的以太网，也称为快速以太网（Fast Ethernet）。</li><li>100BASE-T以太网与10Mb/s标准的传统以太网一样，仍然使用IEEE 802.3的帧格式和CSMA/CD协议。</li><li>100BASE-T以太网为了与10Mb/s标准以太网保持兼容，需要以太网最小帧长保持不变，即仍为64字节。<ul><li>网段的最大电缆长度从1000m减小到100m</li><li>争用期缩短为5.12𝛍𝐬</li><li>帧间最小间隔缩短为0.96𝛍𝐬</li></ul></li><li>100BASE-T以太网还可以使用以太网交换机来提供比集线器更好的服务质量，即在全双工方式下无碰撞工作。使用交换机的100BASE-T以太网，工作在全双工方式下，并不使用CSMA/CD协议。</li></ul><h3 id="2-吉比特以太网"><a class="markdownIt-Anchor" href="#2-吉比特以太网"></a> 2、吉比特以太网</h3><ul><li>IEEE 802.3z千兆以太网的主要特点有：<ul><li>传输速率为1000Mbit/s（1Gb/s）</li><li>使用IEEE 802.3的帧格式（与10Mb/s和100Mb/s以太网相同）</li><li>支持半双工方式（使用CSMA/CD协议）和全双工方式（不使用CSMA/CD协议）</li><li>兼容10BASE-T和100BASE-T技术（网段最大长度仍保持为100m，最小帧长仍保持为64字节）</li></ul></li><li>使用载波延伸（Carrier Extension）技术，将争用期增大为512字节的发送时间而保持最小帧长仍为64字节。</li><li>使用分组突发（Packet Bursting）技术，当有很多短帧要连续发送时，只将第一个短帧用载波延伸的方法进行 填充，而其后面的一系列短帧不用填充就可一个接一个地发送，之间只需空开必要的帧间最小间隔即可。形成 了一连串分组的突发，当累积发送1500字节或稍多一些为止。（思考：请根据以太网信道利用率知识分析原因）</li></ul><h3 id="3-10吉比特以太网"><a class="markdownIt-Anchor" href="#3-10吉比特以太网"></a> 3、10吉比特以太网</h3><ul><li><p>IEEE 802.3ae万兆以太网的主要特点有：</p><ul><li><p>传输速率为10Gbit/s</p></li><li><p>使用IEEE 802.3的帧格式（与10Mb/s、100Mb/s和1Gb/s以太网相同）</p></li><li><p>保留IEEE 802.3标准对以太网最小帧长和最大帧长的规定</p></li><li><p>只工作在全双工方式，不需要使用CSMA/CD协议，这样传输距离就不再受碰撞检测的限制</p></li><li><p>增加了支持城域网和广域网的物理层标准</p></li></ul></li><li><p>万兆以太网交换机常作为千兆以太网的汇聚层交换机，与千兆以太网交换机相连，还可以连接对传输速率要求极高的视频服务器、文件服务器等设备。</p></li></ul><h3 id="4-40100吉比特以太网"><a class="markdownIt-Anchor" href="#4-40100吉比特以太网"></a> 4、40/100吉比特以太网</h3><ul><li>IEEE 802.3ba标准以太网的主要特点有：<ul><li>只工作在全双工方式（不使用CSMA/CD协议）</li><li>仍使用IEEE 802.3标准的帧格式</li><li>遵守最小帧长和最大帧长的规定</li></ul></li></ul><h3 id="5-使用以太网进行宽带接入"><a class="markdownIt-Anchor" href="#5-使用以太网进行宽带接入"></a> 5、使用以太网进行宽带接入</h3><ul><li>以太网宽带接入具有以下特点：<ul><li>可以提供双向的宽带通信。</li><li>可以根据用户对带宽的需求灵活地进行带宽升级。</li><li>可以实现端到端的以太网传输，不需要再进行帧格式的转换，提高了数据的传输效率且降低了传输的成本。</li><li>不支持用户身份鉴别。</li></ul></li><li>把 PPP 协议与以太网协议结合起来：PPPoE (PPP over Ethernet) 的意思是“在以太网上运行 PPP”。<ul><li>将 PPP 帧再封装到以太网中来传输。</li><li>光纤宽带接入 FTTx 都要使用 PPPoE 的方式进行接入，在 PPPoE 弹出的窗口中键入在网络运营商购买的用户名和密码，就可以进行宽带上网了。</li><li>利用 ADSL 进行宽带上网时，从用户个人电脑到家中的 ADSL 调制解调器之间，也是使用 RJ-45 和 5 类线（即以太网使用的网线）进行连接的，并且也是使用 PPPoE 弹出的窗口进行拨号连接的。</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计网</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络第二章 物理层</title>
    <link href="/2024/04/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E7%89%A9%E7%90%86%E5%B1%82/"/>
    <url>/2024/04/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E7%89%A9%E7%90%86%E5%B1%82/</url>
    
    <content type="html"><![CDATA[<h2 id="一-物理层概述"><a class="markdownIt-Anchor" href="#一-物理层概述"></a> 一、物理层概述</h2><h3 id="1-物理层实现的功能"><a class="markdownIt-Anchor" href="#1-物理层实现的功能"></a> 1、物理层实现的功能</h3><ul><li>物理层考虑的是怎样才能在连接各种计算机的传输媒体上传输数据比特流，不是指具体的传输媒体。</li><li>物理层的作用是要尽可能地屏蔽掉不同传输媒体和通信手段的差异。</li><li>用于物理层的协议也常称为物理层规程。</li></ul><h3 id="2-物理层的主要任务确定与传输媒体的接口有关的特性"><a class="markdownIt-Anchor" href="#2-物理层的主要任务确定与传输媒体的接口有关的特性"></a> 2、物理层的主要任务：确定与传输媒体的接口有关的特性</h3><ul><li>机械特性：<ul><li>形状和尺寸</li><li>引脚数目和排列</li><li>固定和锁定装置</li></ul></li><li>电气特性：<ul><li>信号电压的范围</li><li>阻抗匹配的情况</li><li>传输速率</li><li>距离限制</li></ul></li><li>功能特性：<ul><li>出现的某一电平的电压意义（各条信号线的作用）</li></ul></li><li>过程特性<ul><li>各种可能事件的出现顺序（传输比特流的一组操作过程）</li></ul></li></ul><h2 id="二-物理层下面的传输媒体"><a class="markdownIt-Anchor" href="#二-物理层下面的传输媒体"></a> 二、物理层下面的传输媒体</h2><p>传输媒体是计算机网络设备之间的物理通路，也称为传输介质或传输媒介。</p><p>传输媒体并不包含在计算机网络体系结构中。</p><h3 id="1-导引型传输媒体"><a class="markdownIt-Anchor" href="#1-导引型传输媒体"></a> 1、导引型传输媒体</h3><ul><li>双绞线<ul><li>双绞线是最常用的传输媒体。</li><li>模拟传输和数字传输都可以使用双绞线，其通信距离一般为几到十几公里。</li><li>绞合的作用：<ul><li>减少相邻导线间的电磁干扰</li><li>抵御部分来自外界的电磁干扰</li></ul></li><li>绞合度：绞合度越高的双绞线具有越高的数据传送速率。</li></ul></li><li>同轴电缆<ul><li>基带同轴电缆：用于数字传输，在早期局域网中广泛使用。</li><li>宽带同轴电缆：用于模拟传输，目前主要用于有线电视的入户线。</li></ul></li><li>光纤<ul><li>由于可见光的频率非常高（约为108MHz量级），因此一个光纤通信系统的传输带宽远大于目前其他各种传 输媒体的带宽。</li></ul></li></ul><h3 id="2-非导引型传输媒体"><a class="markdownIt-Anchor" href="#2-非导引型传输媒体"></a> 2、非导引型传输媒体</h3><ul><li>无线电</li><li>微波</li><li>红外线</li><li>激光</li><li>可见光</li></ul><h2 id="三-数据通信的基础知识"><a class="markdownIt-Anchor" href="#三-数据通信的基础知识"></a> 三、数据通信的基础知识</h2><h3 id="1-数据通信系统模型"><a class="markdownIt-Anchor" href="#1-数据通信系统模型"></a> 1、数据通信系统模型</h3><ul><li>一个数据通信系统包括三大部分：<ul><li>源系统（发送端、发送方）</li><li>传输系统（传输网络）</li><li>目的系统（接收端、接收方）</li></ul></li><li>常用术语：<ul><li>数据：运送消息的实体</li><li>信号：数据的电气的或电磁的表现</li><li>模拟信号：代表消息的参数的取值是连续的</li><li>数字信号：代表消息的参数的取值是离散的</li></ul></li></ul><h3 id="2-传输方式"><a class="markdownIt-Anchor" href="#2-传输方式"></a> 2、传输方式</h3><ul><li><p>串行传输和并行传输</p><img src="/2024/04/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E7%89%A9%E7%90%86%E5%B1%82/%E4%B8%B2%E8%A1%8C%E4%BC%A0%E8%BE%93%E5%92%8C%E5%B9%B6%E8%A1%8C%E4%BC%A0%E8%BE%93.png" class=""></li><li><p>同步传输和异步传输</p><ul><li>收发双方时钟同步的方法：<ul><li>外同步：在收发双方之间增加一条时钟信号线。</li><li>内同步：发送端将时钟信号编码到发送数据中一起发送（例如曼彻斯特编码）</li></ul></li><li>异步传输：<ul><li>字节之间异步，即字节之间的时间间隔不固定。</li><li>字节中的每个比特仍同步传输然要同步，即各比特的持续时间是相同的。</li></ul></li></ul></li><li><p>单向通信、双向交替通信和双向同时通信</p><ul><li>单项通信：又称为单工通信，即只能有一个方向的通信而没有反方向的交互。</li><li>双向交替通信：又称为半双工通信，即通信的双方都可以发送信息，但不能双方同时发送。</li><li>双向同时通信：又称为全双工通信，即通信的双方可以同时发送和接收消息。</li></ul></li></ul><h3 id="3-编码与调制"><a class="markdownIt-Anchor" href="#3-编码与调制"></a> 3、编码与调制</h3><p>基带信号往往包含有较多的低频成分，甚至有直流成分，而许多信道并不能传输这种低频分量或直流分量，因此必须对基带信号进行调制。</p><ul><li>基带调制（又称为编码）：仅对基带信号的波形进行变换，使它能够与信道特性相适应。变换后的信号仍然是基带信号。</li><li>带通调制：使用载波进行调制，把基带信号的频率范围搬移到较高的频段，并转换为模拟信号，这样就能够更好地在模拟信道中传输（即仅在一段频率范围内能够通过信道）。经过载波调制后的信号成为带通信号。</li><li>码元：在使用时间域的波形表示信号时，代表不同离散数值的基本波形称为码元。</li><li>常用编码方式：<ul><li>双极性不归零编码：<ul><li>正电平代表1，负电平代表0。</li><li>编码效率高，但存在同步问题。</li></ul></li><li>双极性归零编码：<ul><li>正脉冲代表1，负脉冲代表0。</li><li>自同步，但编码效率低。</li></ul></li><li>曼彻斯特编码：<ul><li>位周期中心的向上跳变代表0，位周期中心的向下跳变代表1。也可反过来定义。</li><li>自同步，10Mb/s传统以太网。</li><li>两个码元表示一个比特</li></ul></li><li>差分曼彻斯特编码：<ul><li>在每一位的中心处始终都有跳变。位开始边界有跳变代表0，而位开始边界没有跳变代表1。</li><li>在传输大量连续1或连续0的情况下，差分曼彻斯特编码信号比曼彻斯特编码信号的变化少。</li><li>在噪声干扰环境下，检测有无跳变比检测跳变方向更不容易出错，因此差分曼彻斯特编码信号比曼彻斯特编码信号更易于检测。</li><li>在传输介质接线错误导致高低电平翻转的情况下，差分曼彻斯特编码仍然有效。</li></ul></li></ul></li><li>基本的带通调制方法<ul><li>调幅：载波的振幅随基带数字信号而变化。</li><li>调频：载波的频率随基带数字信号而变化。</li><li>调相：载波的初始相位随基带数字信号而变化。</li></ul></li><li>混合带通调制<ul><li>因为载波的频率和相位是相关的，即频率是相位随时间的变化率，所以载波的频率和相位不能进行混合调制。通常情况下，载波的相位和振幅可以结合起来一起调制，例如正交振幅调制QAM。</li><li>每个码元可携带的比特数=log<sub>2</sub>(相位数乘以振幅数)</li></ul></li></ul><h3 id="4-信道的极限容量"><a class="markdownIt-Anchor" href="#4-信道的极限容量"></a> 4、信道的极限容量</h3><ul><li>造成信号失真的主要因素：<ul><li>码元传输速率高</li><li>传输距离远</li><li>噪声干扰大</li><li>传输媒体质量差</li></ul></li><li>如果数字信号中的高频分量在传输时受到衰减甚至不能通过信道，则接收端接收到的波形前沿和后沿就变得不那么陡峭，每一个码元所占的时间界限也不再明确。这样，在接收端接收到的信号波形就失去了码元之间的清晰界限，这种现象称为<strong>码间串扰</strong>。如果信道的频带越宽，则能够通过的信号的高频分量就越多，那么码元的传输速率就可以更高，而不会导致码间串扰。然而，<strong>信道的频率带宽是有上限的</strong>，不可能无限大。因此，<strong>码元的传输速率也有上限</strong>。</li><li>从概念上讲，限制码元在信道上的传输速率的因素有以下两个：<ul><li>信道能够通过的频率范围</li><li>信噪比</li></ul></li><li>奈氏准则：<ul><li>在带宽为<em><strong>W</strong></em>（Hz）的低通信道中，若不考虑噪声影响，则码元传输的最高速率是<strong>2<em>W</em></strong>（码元/秒）。传输速率超过此上限，就会出现严重的码间串扰问题，使接收端对码元的判决成为不可能。</li><li>码元传输速率又称为波特率、调制速率、波形速率或符号速率。</li><li>波特率与比特率有一定的关系：<ul><li>当1个码元只携带1比特的信息量时，波特率（码元/秒）与比特率（比特/秒）在数值上是相等的。</li><li>当1个码元携带n比特的信息量时，波特率（码元/秒）转换成比特率（比特/秒）时，要乘以n。</li></ul></li></ul></li><li>香农公式：<ul><li>信噪比：<ul><li>信号的平均功率和噪声的平均功率之比，常记为S/N。</li><li><strong>信噪比（dB）=10log<sub>10</sub>（S/N）（dB）</strong></li></ul></li><li>带宽受限且有高斯白噪声干扰的信道的极限信息传输速率：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi><mrow><mi mathvariant="bold-italic">C</mi><mo>=</mo><mi mathvariant="bold-italic">W</mi><mi mathvariant="bold-italic">l</mi><mi mathvariant="bold-italic">o</mi><msub><mi mathvariant="bold-italic">g</mi><mn mathvariant="bold">2</mn></msub><mo stretchy="false">(</mo><mn mathvariant="bold">1</mn><mo mathvariant="bold-italic">+</mo><mi mathvariant="bold-italic">S</mi><mi mathvariant="bold">/</mi><mi mathvariant="bold-italic">N</mi><mo stretchy="false">)</mo></mrow></mi></mrow><annotation encoding="application/x-tex">\boldsymbol{C=Wlog_{2}(1+S/N)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord"><span class="mord boldsymbol" style="margin-right:0.06979em;">C</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel mathbf">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord boldsymbol" style="margin-right:0.15972em;">W</span><span class="mord boldsymbol" style="margin-right:0.0088em;">l</span><span class="mord boldsymbol">o</span><span class="mord"><span class="mord boldsymbol" style="margin-right:0.03704em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03704em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathbf mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen mathbf">(</span><span class="mord mathbf">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin mathbf">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord boldsymbol" style="margin-right:0.05382em;">S</span><span class="mord mathbf">/</span><span class="mord boldsymbol" style="margin-right:0.11424em;">N</span><span class="mclose mathbf">)</span></span></span></span></span></span><ul><li>C：信道的极限信息传输速率（单位为bit/s）</li><li>W：信道的频率带宽（单位为Hz）</li><li>S/N：信噪比，使用分贝（dB）作为度量单位</li></ul></li></ul></li></ul><h2 id="四-信道复用技术"><a class="markdownIt-Anchor" href="#四-信道复用技术"></a> 四、信道复用技术</h2><h3 id="1-信道复用技术基本概念"><a class="markdownIt-Anchor" href="#1-信道复用技术基本概念"></a> 1、信道复用技术基本概念</h3><ul><li>复用就是在一条传输媒体上同时传输多路用户的信号，降低成本，提高利用率。</li><li>当一条传输媒体的传输容量大于多条信道传输的总容量时，就可以通过复用技术，在这条传输 媒体上建立多条通信信道，以便充分利用传输媒体的带宽。</li></ul><h3 id="2-常用的信道复用技术"><a class="markdownIt-Anchor" href="#2-常用的信道复用技术"></a> 2、常用的信道复用技术</h3><ul><li><p>频分复用FDM</p><ul><li><p>有多路信号在一个信道中传送，可以使用调制的方法，把各路信号分别搬移到适当的频率位置，使彼此不产生干扰。</p></li><li><p>频分复用的所有用户<strong>同时占用不同的频带资源</strong>并行通信。</p></li></ul></li><li><p>时分复用TDM</p><ul><li><p>时分复用是将时间划分为一段段等长的时分复用帧（TDM 帧）。每一个时分复用的用户在每一个 TDM 帧中占用固定序号的时隙。各用户时隙周期性出现，周期为TDM帧的长度。</p></li><li><p>时分复用的所有用户<strong>在不同的时间占用同样的频带</strong>。</p></li></ul></li><li><p>波分复用WDM</p><ul><li>可在一根光纤上同时传输多个频率（波长）相近的光载波信号，实现基于光纤的频分复用技术。</li><li>目前可以在一根光纤上复用80路或更多路的光载波信号。因此，这种复用技术也称为密集波分复用DWDM。</li></ul></li><li><p>码分复用CDM</p><ul><li>当码分复用信道为多个不同地址的用户所共享时，就称为码分多址。</li><li>与FDM和TDM不同，CDMA的每个用户可以在<strong>相同的时间使用相同的频带</strong>进行通信。</li><li>CDMA将每个比特时间划分为m个更短的时间片，称为码片。m的取值通常为64或128。</li><li>CDMA中的每个站点都被指派一个唯一的 m 比特码片序列。<ul><li>某个站要发送比特1，则发送它自己的m比特码片序列。</li><li>某个站要发送比特0，则发送它自己的m比特码片序列的二进制反码。</li><li>将码片序列中的比特0记为-1，而比特1记为+1，可写出码片序列相应的码片向量。</li></ul></li><li>如果有两个或多个站同时发送数据，则信道中的信号就是这些站各自所发送一系列码片序列或码片序列反码的叠加。为了从信道中分离出每个站的信号，给每个站指派码片序列时，必须遵循以下规则：<ul><li>分配给每个站的<strong>码片序列必须各不相同</strong>，实际常采用伪随机码序列。</li><li>分配给每个站的<strong>码片序列必须相互正交</strong>，即各码片序列相应的码片向量之间的<strong>规格化內积为0</strong>。</li></ul></li><li>码片向量的性质：<ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>⋅</mo><mi>B</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">A\cdot B=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>⋅</mo><mover accent="true"><mi>B</mi><mo stretchy="true">‾</mo></mover><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">A\cdot \overline{B}=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8833300000000001em;vertical-align:0em;"></span><span class="mord overline"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8833300000000001em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span><span style="top:-3.80333em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>⋅</mo><mi>A</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">A\cdot A=1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>⋅</mo><mover accent="true"><mi>A</mi><mo stretchy="true">‾</mo></mover><mo>=</mo><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">A\cdot \overline{A}=-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8833300000000001em;vertical-align:0em;"></span><span class="mord overline"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8833300000000001em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">A</span></span></span><span style="top:-3.80333em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">−</span><span class="mord">1</span></span></span></span></li></ul></li><li>各接收站用自己的码片向量与收到的叠加后的码片向量，做<strong>规格化內积</strong>运算：<ul><li>运算结果为1，表明收到的是比特1</li><li>运算结果为0，表明收到的是比特0</li></ul></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计网</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络第一章 概述</title>
    <link href="/2024/04/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC%E4%B8%80%E7%AB%A0-%E6%A6%82%E8%BF%B0/"/>
    <url>/2024/04/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC%E4%B8%80%E7%AB%A0-%E6%A6%82%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<div class="row">    <embed src="https://Wyz10006.github.io/file/ComputerNetwork1.pdf" width="100%" height="550" type="application/pdf"></div>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计网</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
