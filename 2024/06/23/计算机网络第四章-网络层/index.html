

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/%E9%A6%96%E9%A1%B5.jpg">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="心逍遥">
  <meta name="keywords" content="">
  
    <meta name="description" content="一、网络层概述  1、网络层提供的两种服务  面向连接的虚电路服务  核心思想：可靠通信应由网络自身来保证。 必须首先建立网络层连接：虚电路（Virtual Circuit，VC），以保证通信双方所需的一切网络资源。  虚电路表示这是一条逻辑上的连接，分组沿着这条逻辑连接按照存储转发方式传送，而不是真正建立了一条物理连接。 而采用电路交换，是先建立一条真正的物理连接。因此，分组交换的虚连接与电路">
<meta property="og:type" content="article">
<meta property="og:title" content="计算机网络第四章 网络层">
<meta property="og:url" content="https://wyz10006.github.io/2024/06/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E7%BD%91%E7%BB%9C%E5%B1%82/index.html">
<meta property="og:site_name" content="心逍遥的博客">
<meta property="og:description" content="一、网络层概述  1、网络层提供的两种服务  面向连接的虚电路服务  核心思想：可靠通信应由网络自身来保证。 必须首先建立网络层连接：虚电路（Virtual Circuit，VC），以保证通信双方所需的一切网络资源。  虚电路表示这是一条逻辑上的连接，分组沿着这条逻辑连接按照存储转发方式传送，而不是真正建立了一条物理连接。 而采用电路交换，是先建立一条真正的物理连接。因此，分组交换的虚连接与电路">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://wyz10006.github.io/2024/06/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E7%BD%91%E7%BB%9C%E5%B1%82/1.png">
<meta property="og:image" content="https://wyz10006.github.io/2024/06/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E7%BD%91%E7%BB%9C%E5%B1%82/2.png">
<meta property="og:image" content="https://wyz10006.github.io/2024/06/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E7%BD%91%E7%BB%9C%E5%B1%82/3.png">
<meta property="og:image" content="https://wyz10006.github.io/2024/06/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E7%BD%91%E7%BB%9C%E5%B1%82/4.png">
<meta property="og:image" content="https://wyz10006.github.io/2024/06/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E7%BD%91%E7%BB%9C%E5%B1%82/5.png">
<meta property="og:image" content="https://wyz10006.github.io/2024/06/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E7%BD%91%E7%BB%9C%E5%B1%82/6.png">
<meta property="og:image" content="https://wyz10006.github.io/2024/06/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E7%BD%91%E7%BB%9C%E5%B1%82/7.png">
<meta property="og:image" content="https://wyz10006.github.io/2024/06/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E7%BD%91%E7%BB%9C%E5%B1%82/8.png">
<meta property="og:image" content="https://wyz10006.github.io/2024/06/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E7%BD%91%E7%BB%9C%E5%B1%82/9.png">
<meta property="og:image" content="https://wyz10006.github.io/2024/06/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E7%BD%91%E7%BB%9C%E5%B1%82/10.png">
<meta property="og:image" content="https://wyz10006.github.io/2024/06/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E7%BD%91%E7%BB%9C%E5%B1%82/11.png">
<meta property="og:image" content="https://wyz10006.github.io/2024/06/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E7%BD%91%E7%BB%9C%E5%B1%82/12.png">
<meta property="og:image" content="https://wyz10006.github.io/2024/06/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E7%BD%91%E7%BB%9C%E5%B1%82/13.png">
<meta property="og:image" content="https://wyz10006.github.io/2024/06/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E7%BD%91%E7%BB%9C%E5%B1%82/14.png">
<meta property="og:image" content="https://wyz10006.github.io/2024/06/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E7%BD%91%E7%BB%9C%E5%B1%82/15.png">
<meta property="og:image" content="https://wyz10006.github.io/2024/06/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E7%BD%91%E7%BB%9C%E5%B1%82/16.png">
<meta property="og:image" content="https://wyz10006.github.io/2024/06/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E7%BD%91%E7%BB%9C%E5%B1%82/17.png">
<meta property="og:image" content="https://wyz10006.github.io/2024/06/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E7%BD%91%E7%BB%9C%E5%B1%82/18.png">
<meta property="og:image" content="https://wyz10006.github.io/2024/06/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E7%BD%91%E7%BB%9C%E5%B1%82/19.png">
<meta property="article:published_time" content="2024-06-23T11:41:12.000Z">
<meta property="article:modified_time" content="2024-06-23T11:41:25.835Z">
<meta property="article:author" content="心逍遥">
<meta property="article:tag" content="计网">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://wyz10006.github.io/2024/06/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E7%BD%91%E7%BB%9C%E5%B1%82/1.png">
  
  
  
  <title>计算机网络第四章 网络层 - 心逍遥的博客</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/KaTeX/0.16.2/katex.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  



  
<link rel="stylesheet" href="/css/meihua.css">



  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"wyz10006.github.io","root":"/","version":"1.9.7","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":"Tge3H6EIi2Wf2Gpf9l7LsHS1-gzGzoHsz","app_key":"3LOGiBjL7YN8wgXZXHDkhDZD","server_url":"https://tge3h6ei.lc-cn-n1-shared.com","path":"window.location.pathname","ignore_local":true}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  

  

  
    <!-- Google tag (gtag.js) -->
    <script async>
      if (!Fluid.ctx.dnt) {
        Fluid.utils.createScript("https://www.googletagmanager.com/gtag/js?id=", function() {
          window.dataLayer = window.dataLayer || [];
          function gtag() {
            dataLayer.push(arguments);
          }
          gtag('js', new Date());
          gtag('config', '');
        });
      }
    </script>
  

  

  

  

  
    
  



  
<meta name="generator" content="Hexo 7.1.1"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>心逍遥的博客</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/none.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="计算机网络第四章 网络层"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2024-06-23 19:41" pubdate>
          2024年6月23日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          14k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          114 分钟
        
      </span>
    

    
    
      
        <span id="leancloud-page-views-container" class="post-meta" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="leancloud-page-views"></span> 次
        </span>
        
      
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">计算机网络第四章 网络层</h1>
            
            
              <div class="markdown-body">
                
                <h2 id="一-网络层概述"><a class="markdownIt-Anchor" href="#一-网络层概述"></a> 一、网络层概述</h2>
<h3 id="1-网络层提供的两种服务"><a class="markdownIt-Anchor" href="#1-网络层提供的两种服务"></a> 1、网络层提供的两种服务</h3>
<h4 id="面向连接的虚电路服务"><a class="markdownIt-Anchor" href="#面向连接的虚电路服务"></a> 面向连接的虚电路服务</h4>
<ul>
<li>核心思想：可靠通信应由网络自身来保证。</li>
<li>必须首先建立网络层连接：<strong>虚电路</strong>（Virtual Circuit，VC），以保证通信双方所需的一切网络资源。
<ul>
<li>虚电路表示这是一条逻辑上的连接，分组沿着这条逻辑连接按照存储转发方式传送，而不是真正建立了一条物理连接。</li>
<li>而采用电路交换，是先建立一条真正的物理连接。因此，分组交换的虚连接与电路交换的连接只是类似，但并不一样。</li>
<li>分组的首部仅在连接建立阶段使用完整的目的主机地址，之后每个分组的首部只需要携带一条虚电路编号即可。</li>
</ul>
</li>
<li>通信双方沿着已建立的虚电路发送分组。</li>
<li>通信结束后，需要<strong>释放</strong>之前所建立的虚电路。</li>
<li>这种通信方式再使用可靠传输的网络协议，就可使所发送的分组最终正确（无差错、按顺序、不丢失、不重复）到达接收方。</li>
<li>因特网的先驱者并没有采用这种设计思想，而是采用了无连接的数据报服务。</li>
</ul>
<h4 id="无连接的数据报服务"><a class="markdownIt-Anchor" href="#无连接的数据报服务"></a> 无连接的数据报服务</h4>
<ul>
<li>
<p>核心思想：可靠通信应由用户主机（端系统）来保证。</p>
</li>
<li>
<p>不需要建立网络层连接，尽最大努力交付。</p>
</li>
<li>
<p>每个分组可走不同的路径，每个分组的首部都必须携带目的主机的完整地址。</p>
</li>
<li>
<p>通信结束后，没有需要释放的连接。</p>
</li>
<li>
<p>将复杂的网络处理功能置于因特网的边缘（即用户主机和其内部的运输层），将相对简单的尽最大努力（即不可靠）的分组交付功能置于因特网核心。</p>
</li>
</ul>
<h3 id="2-网络层的两个层面"><a class="markdownIt-Anchor" href="#2-网络层的两个层面"></a> 2、网络层的两个层面</h3>
<ul>
<li>网络层的主要任务就是将分组从源主机经过多个网络和多段链路传输到目的主机</li>
<li>可以将该任务划分为<strong>分组转发</strong>和<strong>路由选择</strong>两种重要的功能。</li>
<li>可以把网络层抽象地划分为<strong>数据层面（转发层面）和控制层面</strong>。</li>
</ul>
<img src="/2024/06/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E7%BD%91%E7%BB%9C%E5%B1%82/1.png" srcset="/img/loading.gif" lazyload class="">
<h2 id="二-网际协议ip"><a class="markdownIt-Anchor" href="#二-网际协议ip"></a> 二、网际协议IP</h2>
<h3 id="1-虚拟互连网络"><a class="markdownIt-Anchor" href="#1-虚拟互连网络"></a> 1、虚拟互连网络</h3>
<ul>
<li>将网络互相连接起来要使用一些中间设备。中间设备又称为中间系统或中继 (relay)系统。</li>
<li>有以下五种不同的中间设备：
<ul>
<li>物理层中继系统：转发器 (repeater)、集线器（hub）</li>
<li>数据链路层中继系统：网桥 (bridge)、交换机（switch）</li>
<li>网络层中继系统：路由器 (router)
<ul>
<li>网桥和路由器的混合物：桥路器 (brouter)</li>
</ul>
</li>
<li>网络层以上的中继系统：网关 (gateway)</li>
</ul>
</li>
<li>当中继系统是转发器、集线器或网桥时，并不称之为网络互连，因为这仅仅是把一个网络扩大了，而这仍然是一个网络。</li>
<li>网络互连：指使用<strong>路由器</strong>进行网络互连和路由选择。</li>
<li>虚拟互连网络：逻辑互连网络。
<ul>
<li>指互连起来的各种物理网络的异构性本来是客观存在的，但是我们<strong>利用IP协议就可以使这些性能各异的网络在网络层上看起来好像是一个统一的网络</strong>。</li>
<li>使用 IP 协议的虚拟互连网络可简称为 IP 网。</li>
<li>当互联网上的主机进行通信时，就好像在一个网络上通信一样，而看不见互连的各具体网络异构细节。</li>
<li>如果在这种覆盖全球的 IP 网的上层（运输层）使用 TCP 协议，那么就是现在的互联网(Internet)。</li>
</ul>
</li>
<li>如果我们只从网络层考虑问题，那么 IP 数据报就可以想象是在网络层中传送。
<ul>
<li>分组在传送过程中每一次转发都称为一“跳（hop）”。</li>
<li>每一跳两端的两个节点一定直接连在同一个网络上。</li>
</ul>
</li>
</ul>
<h3 id="2-ip地址ipv4"><a class="markdownIt-Anchor" href="#2-ip地址ipv4"></a> 2、IP地址（IPv4）</h3>
<p>IPv4地址是给互联网上每一个主机/路由器的<strong>每一个接口</strong>分配的一个在全世界范围内唯一的32比特的标识符。</p>
<h4 id="ip地址的表示方法"><a class="markdownIt-Anchor" href="#ip地址的表示方法"></a> IP地址的表示方法</h4>
<ul>
<li>由于IPv4地址由32比特构成，IPv4地址采用点分十进制表示方法以提高可读性。</li>
</ul>
<img src="/2024/06/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E7%BD%91%E7%BB%9C%E5%B1%82/2.png" srcset="/img/loading.gif" lazyload class="">
<h4 id="分类编址方法"><a class="markdownIt-Anchor" href="#分类编址方法"></a> 分类编址方法</h4>
<ul>
<li>将 IP 地址划分为若干个固定类。每一类地址都由两个固定长度的字段组成，其中一个字段是网络号 net-id，它标志主机（或路由器）所连接到的网络，而另一个字段则是主机号 host-id，它标志该主机（或路由器）。</li>
<li>主机号在它所连接的网络中（前面的网络号所指明的网络）必须是唯一的。</li>
<li>一个 IP 地址在整个互联网范围内是唯一的。</li>
</ul>
<img src="/2024/06/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E7%BD%91%E7%BB%9C%E5%B1%82/3.png" srcset="/img/loading.gif" lazyload class="">
<img src="/2024/06/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E7%BD%91%E7%BB%9C%E5%B1%82/4.png" srcset="/img/loading.gif" lazyload class="">
<ul>
<li>
<p>A类、B类和C类地址都是单播地址，只有单播地址可以分配给网络中的主机（或路由器）的各接口。</p>
</li>
<li>
<p>主机号为“全 0”的地址是<strong>网络地址</strong>，不能分配给主机（或路由器）的各接口。</p>
</li>
<li>
<p>主机号为“全 1”的地址是<strong>广播地址</strong>，不能分配给主机（或路由器）的各接口。</p>
</li>
<li>
<p>最小网络号为0，表示<strong>本网络</strong>，不能指派。</p>
</li>
<li>
<p>最大网络号为127，作为本地<strong>环回测试地址</strong>，不能指派。</p>
</li>
<li>
<p><strong>可指派</strong>的A类<strong>网络数量</strong>为 2<sup>(8-1)</sup>-2=126（减2是去掉最小网络号0和最大网络号127）</p>
</li>
<li>
<p>每个A类网络中<strong>可分配</strong>的<strong>地址数量</strong>为 2<sup>24</sup>-2=16777214（减2是去掉主机号为全0的网络地址和全1的广播地址）</p>
</li>
</ul>
<img src="/2024/06/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E7%BD%91%E7%BB%9C%E5%B1%82/5.png" srcset="/img/loading.gif" lazyload class="">
<h4 id="划分子网编址方法"><a class="markdownIt-Anchor" href="#划分子网编址方法"></a> 划分子网编址方法</h4>
<ul>
<li>随着更多的中小网络加入互联网，IPv4分类编址方法不够灵活、容易造成大量IPv4地址资源浪费。</li>
<li>划分子网编址方法对分类编址方法进行改进。在IP地址的主机号中，插入一个子网号，把两级的IP地址变为三级的IP地址。</li>
<li>子网掩码可以表明分类IPv4地址的主机号部分被借用了几个比特作为子网号。</li>
<li>与IPv4地址类似，子网掩码也是由32比特构成的。
<ul>
<li>用左起多个连续的比特1对应IPv4地址中的网络号和子网号；</li>
<li>之后的多个连续的比特0对应IPv4地址中的主机号。</li>
</ul>
</li>
<li>将划分子网的IPv4地址与相应的子网掩码进行逐比特的逻辑与运算，可得到该IPv4地址所在子网的<strong>网络地址</strong>。</li>
<li>默认子网掩码：是指在未划分子网的情况下使用的子网掩码。</li>
</ul>
<h4 id="无分类编址方法-cidr"><a class="markdownIt-Anchor" href="#无分类编址方法-cidr"></a> 无分类编址方法 CIDR</h4>
<ul>
<li>
<p>无分类编址方法使用的地址掩码与划分子网使用的子网掩码类似，由32比特构成。</p>
<ul>
<li>左起多个连续的比特1对应IPv4地址中的网络前缀；</li>
<li>之后的多个连续的比特0对应IPv4地址中的主机号。</li>
</ul>
</li>
<li>
<p>斜线记法（CIDR记法）：可以不明确给出配套的地址掩码的点分十进制形式，而是在无分类编址的IPv4地址后面加上斜线“/” ，在斜线之后写上<strong>网络前缀所占的比特数量</strong>（也就是地址掩码中左起连续比特1的数量）</p>
</li>
<li>
<p>实际上，无分类域间路由选择CIDR是将网络前缀都相同的、连续的多个无分类IPv4地址，组成一个CIDR地址块（网络前缀都相同的所有连续的IP地址）。</p>
</li>
<li>
<p>使用无分类编址方法，可以根据需要，分配适当大小的CIDR地址块，更加有效地分配IPv4的地址空间。</p>
</li>
<li>
<p>划分子网 (subnetting)：网络前缀越短，地址块所包含的地址数就越多。在三级结构IP地址中，划分子网使网络前缀变长。</p>
</li>
<li>
<p>构造超网 (supernetting)：前缀不超过 23 位的 CIDR 地址块含多个 C 类地址，这些C类地址合起来构成超网。</p>
<ul>
<li>构成超网也称为路由聚合。</li>
<li>一个 CIDR 地址块可以表示很多地址，这种地址的聚合常称为路由聚合，它使得路由表中的一个项目可以表示很多个（例如上千个）原来传统分类地址的路由。</li>
<li>路由聚合有利于减少路由器之间的路由选择信息的交换，从而提高了整个互联网的性能。</li>
</ul>
</li>
<li>
<p>CIDR 地址块中的地址数一定是 2 的整数次幂。</p>
</li>
<li>
<p>CIDR 可以更加有效地分配 IPv4 的地址空间，可根据客户的需要分配适当大小的CIDR地址块。</p>
</li>
</ul>
<h4 id="ip地址的特点"><a class="markdownIt-Anchor" href="#ip地址的特点"></a> IP地址的特点</h4>
<ul>
<li>
<p>IP 地址是一种<strong>分等级的地址结构</strong>，好处是：</p>
</li>
<li>
<p>第一，IP 地址管理机构在分配 IP 地址时只分配网络号，而剩下的主机号则由得到该网络号的单位自行分配，方便了 IP 地址的管理。</p>
</li>
<li>
<p>第二，路由器<strong>仅根据目的主机所连接的网络号</strong>来转发分组（而不考虑目的主机号），这样就可以使路由表中的项目数大幅度减少，从而减小了路由表所占的存储空间。</p>
</li>
<li>
<p>实际上 IP 地址是标志一个主机（或路由器）和一条链路的<strong>接口</strong>。</p>
<ul>
<li>当一个主机同时连接到两个网络上时，该主机就必须同时具有两个相应的IP 地址，其网络号net-id必须是不同的，这种主机称为多归属主机 (multihomed host)。</li>
<li>由于一个路由器至少应当连接到两个网络（这样它才能将 IP 数据报从一个网络转发到另一个网络），因此<strong>一个路由器至少应当有两个不同的 IP 地址</strong>。</li>
<li>两个路由器直接相连的接口处，可指明也可不指明 IP 地址。如指明IP 地址，则这一段连线就构成了一种只包含一段线路的特殊“网络”。现在常不指明 IP 地址。</li>
</ul>
</li>
<li>
<p>用转发器或网桥连接起来的若干个局域网仍为一个网络，因此这些局域网都具有同样的网络号net-id。</p>
</li>
<li>
<p>所有分配到网络号 net-id 的网络，无论是范围很小的局域网，还是覆盖很大地理范围的广域网，都是平等的。</p>
</li>
</ul>
<h4 id="ip地址的综合规划"><a class="markdownIt-Anchor" href="#ip地址的综合规划"></a> IP地址的综合规划</h4>
<ul>
<li>IP地址的综合应用是指将给定的IP地址块（或分类网络）划分成若干个更小的地址块（或子网），并将这些地址块（或子网）分配给互联网中的不同网络，进而可以给各网络中的主机和路由器的接口分配IP地址。</li>
<li>定长的子网掩码
<ul>
<li>所划分出的每一个子网都使用同一个子网掩码。</li>
<li>每个子网所分配的IP地址数量相同，容易造成地址资源的浪费。</li>
<li>
<img src="/2024/06/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E7%BD%91%E7%BB%9C%E5%B1%82/6.png" srcset="/img/loading.gif" lazyload class="">
</li>
</ul>
</li>
<li>变长的子网掩码
<ul>
<li>所划分出的每一个子网可以使用不同的子网掩码。</li>
<li>每个子网所分配的IP地址数量可以不同，尽可能减少对地址资源的浪费。</li>
<li>
<img src="/2024/06/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E7%BD%91%E7%BB%9C%E5%B1%82/7.png" srcset="/img/loading.gif" lazyload class="">
</li>
</ul>
</li>
</ul>
<h4 id="ip地址与mac地址"><a class="markdownIt-Anchor" href="#ip地址与mac地址"></a> IP地址与MAC地址</h4>
<ul>
<li>
<p>IP 地址与MAC地址（硬件地址或物理地址）是不同的地址。</p>
</li>
<li>
<p>封装位置</p>
<ul>
<li>MAC地址是数据链路层和物理层使用的地址。</li>
<li>IP 地址是网络层和以上各层使用的地址，是一种逻辑地址（是因为IP 地址是用软件实现的）。</li>
</ul>
</li>
<li>
<p>数据传送过程</p>
<ul>
<li>在数据包的传送过程中，数据包的源IP地址和目的IP地址保持不变；</li>
<li>在数据包的传送过程中，数据包的源MAC地址和目的MAC地址逐链路（或逐网络）改变。</li>
</ul>
</li>
</ul>
<h3 id="3-地址解析协议arp"><a class="markdownIt-Anchor" href="#3-地址解析协议arp"></a> 3、地址解析协议ARP</h3>
<ul>
<li>
<p>地址解析协议（Address Resolution Protocol，ARP）是一种在TCP/IP网络中用于将IP地址映射到物理MAC地址的协议。</p>
</li>
<li>
<p>每个主机都有一个ARP高速缓存，里面有所在的局域网上的各主机和路由器IP地址到MAC地址的映射表。<br />
&lt; IP address；MAC address；TTL &gt; TTL (Time To Live)：地址映射有效时间</p>
</li>
<li>
<p>当主机A欲向本局域网上的某个主机B发送IP数据报时，先在其ARP高速缓存中查看有无主机B的IP地址。</p>
<ul>
<li>如有，就可查出其对应的硬件地址，再将此硬件地址写入MAC帧，通过局域网将该MAC帧发往此MAC地址。</li>
<li>如没有，ARP进程在本局域网上广播发送一个ARP请求分组。收到ARP响应分组后，将得到的IP地址到MAC地址的映射写入ARP高速缓存。</li>
</ul>
</li>
<li>
<p>转发表中的MAC地址与交换机接口号的对应关系记录也要周期性删除，因为这种对应关系并不是永久不变的。同理，ARP高速缓存表中的IP地址与MAC地址的对应关系也并不是永久不变的。例如，主机更换了一块新网卡。</p>
</li>
<li>
<p>ARP请求分组：包含发送方 MAC 地址 / 发送方 IP 地址 / 目标方 MAC 地址(未知时填0) / 目标方IP地址。</p>
</li>
<li>
<p>ARP响应分组：包含发送方 MAC 地址 / 发送方 IP地址 / 目标方 MAC 地址/ 目标方IP 地址。</p>
<ul>
<li>为了减少网络上的通信量，主机A在发送ARP请求分组时，将自己IP地址到MAC地址映射写入请求分组。</li>
<li>当主机B收到A的ARP请求分组时，将主机A的这一地址映射写入自己的ARP高速缓存中（方便以后发送）。</li>
</ul>
</li>
<li>
<p><strong>ARP 是解决同一个局域网上的主机或路由器的 IP 地址和MAC地址的映射问题</strong>。</p>
<ul>
<li>本地广播 ARP 请求（路由器不转发ARP请求）</li>
</ul>
</li>
<li>
<p>如果所要找的主机和源主机不在同一个局域网上，那么就要通过ARP找到一个位于本局域网上的某个路由器的MAC地址，然后把分组发送给这个路由器，让这个路由器把分组转发给下一个网络。</p>
</li>
<li>
<p>从IP地址到MAC地址的解析是自动进行的，主机的用户对这种地址解析过程是不知道的。</p>
<ul>
<li>只要主机或路由器要和本网络上的另一个已知IP地址的主机或路由器进行通信，ARP协议就会自动地将该IP地址解析为链路层所需要的MAC地址。</li>
</ul>
</li>
<li>
<p>ARP协议没有安全验证机制，存在ARP欺骗和攻击等问题。</p>
</li>
</ul>
<h3 id="4-ip数据报"><a class="markdownIt-Anchor" href="#4-ip数据报"></a> 4、IP数据报</h3>
<ul>
<li>一个IP数据报由首部和数据两部分组成。</li>
<li>IP数据报的首部：
<ul>
<li>首部的前一部分是<strong>固定长度</strong>，共 <strong>20 字节</strong>，是所有IP数据报必须具有的。</li>
<li>首部固定部分的后面是一些可选字段，其长度是可变的。</li>
<li>IP数据报首部中的各字段或某些字段的组合，用来表达IP协议的相关功能。</li>
</ul>
</li>
</ul>
<img src="/2024/06/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E7%BD%91%E7%BB%9C%E5%B1%82/8.png" srcset="/img/loading.gif" lazyload class="">
<ul>
<li>
<p>版本</p>
<ul>
<li>长度为4个比特，用来表示IP协议的版本。</li>
<li>通信双方使用的IP协议的版本必须一致。</li>
<li>目前广泛使用的IP协议的版本号为4（即IPv4）。</li>
</ul>
</li>
<li>
<p>首部长度</p>
<ul>
<li>长度为4个比特，该字段的取值<strong>以4字节为单位</strong>，用来表示IP数据报的首部长度。</li>
<li>最小取值为二进制的0101，即十进制的5，再乘以4字节单位，表示IPv4数据报首部只有20字节固定部分。</li>
<li>最大取值为二进制的1111，即十进制的15，再乘以4字节单位，表示IPv4数据报首部包含20字节固定部分和最大40字节可变部分。</li>
</ul>
</li>
<li>
<p>可选字段</p>
<ul>
<li>长度从1字节到40字节不等（取决于所选的项目），用来支持排错、测量以及安全措施等功能。</li>
<li>虽然可选字段增加了IP数据报的功能，但这同时也使得IP数据报的首部长度成为可变的，这就增加了每一个路由器处理IP数据报的开销。</li>
<li>实际上，<strong>可选字段很少被使用</strong>。</li>
</ul>
</li>
<li>
<p>填充</p>
<ul>
<li>用来确保IP数据报的首部长度是4字节的整数倍，使用全0进行填充。</li>
<li>当首部长度（20字节固定部分+可变部分）的长度不是4字节整数倍时，填充相应数量的全0字节，以确保IP数据报的首部长度是4字节的整数倍。</li>
</ul>
</li>
<li>
<p>区分服务</p>
<ul>
<li>长度为8个比特，用来获得更好的服务。</li>
<li>利用该字段的不同取值可提供不同等级的服务质量。</li>
<li>只有在使用区分服务时该字段才起作用，一般情况下都不使用该字段。</li>
</ul>
</li>
<li>
<p>总长度</p>
<ul>
<li>长度为16个比特，该字段的取值以字节为单位，用来表示IP数据报的长度（首部长度+数据载荷长度）。</li>
<li>最大取值为二进制的16个比特1，即十进制的65535（很少传输这么长的IP数据报）。</li>
</ul>
</li>
<li>
<p>标识</p>
<ul>
<li>长度为16个比特，<strong>属于同一个IP数据报的各分片数据报应该具有相同的标识</strong>。</li>
<li>IP软件会维持一个计数器，每产生一个IP数据报，计数器值就加1，并将此值赋给标识字段。</li>
</ul>
</li>
<li>
<p>标志</p>
<ul>
<li>最低位（More Fragment，MF）
<ul>
<li>MF=1表示本分片后还有分片</li>
<li>MF=0表示本分片后没有分片</li>
</ul>
</li>
<li>中间位（Don’t Fragment，DF）
<ul>
<li>DF=1表示不允许分片</li>
<li>DF=0表示允许分片</li>
</ul>
</li>
<li>最高位为保留位，必须设置为0</li>
</ul>
</li>
<li>
<p>IP数据报分片</p>
<ul>
<li>原始数据报首部被复制为各数据报片的首部，但必须修改有关字段的值。</li>
<li>IP数据报越短，路由器转发的速度越快。</li>
<li>IP协议规定，在互联网中的所有主机和路由器必须能够接收长度不超过576字节的数据报。</li>
</ul>
</li>
<li>
<p>片偏移</p>
<ul>
<li>该字段的取值以8字节为单位，用来指出分片IP数据报的数据载荷偏移其在原IP数据报的位置有多远。</li>
<li>相对于用户数据字段的起点的偏移。</li>
<li><strong>除最后一个数据报分片，其他每个分片的长度一定是8字节的整数倍</strong>。</li>
</ul>
</li>
<li>
<p>生存时间（Time To Live，TTL）</p>
<ul>
<li>长度为8个比特，最大取值为二进制的11111111，即十进制的255。该字段的取值最初以秒为单位。因此，IP数据报的最大生存时间最初为255秒。路由器转发IP数据报时，将其首部中该字段的值减去该数据报在路由器上所耗费的时间，若结果不为0就转发，否则就丢弃。</li>
<li>生存时间字段后来改为<strong>以“跳数”为单位</strong>，路由器收到待转发的IP数据报时，将其首部中的该字段的值减1，若结果不为0就转发，否则就丢弃（<strong>数据报能在互联网中经过路由器的最大数值是256</strong>）。</li>
</ul>
</li>
<li>
<p>首部检验和</p>
<ul>
<li>长度为16个比特，检测IP数据报在传输过程中其首部是否出现了差错。（只检验首部，不包括数据部分）</li>
<li>IP数据报每经过一个路由器，其首部中的某些字段的值（例如生存时间TTL、标志以及片偏移等）都可能发生变化，因此路由器都要重新计算一下首部检验和。</li>
<li>IP首部检验和不采用复杂的循环冗余检验CRC，检错性能虽然不如CRC，但更易用软件实现。</li>
<li>计算方法：
<ul>
<li>
<img src="/2024/06/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E7%BD%91%E7%BB%9C%E5%B1%82/9.png" srcset="/img/loading.gif" lazyload class="">
</li>
<li>
<img src="/2024/06/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E7%BD%91%E7%BB%9C%E5%B1%82/10.png" srcset="/img/loading.gif" lazyload class="">
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>源IP地址</p>
<ul>
<li>长度为32个比特，用来填写发送IP数据报的源主机的IP地址。</li>
</ul>
</li>
<li>
<p>目的IP地址</p>
<ul>
<li>长度为32个比特，用来填写接收IP数据报的目的主机的IP地址。</li>
</ul>
</li>
</ul>
<h2 id="三-ip层转发分组的过程"><a class="markdownIt-Anchor" href="#三-ip层转发分组的过程"></a> 三、IP层转发分组的过程</h2>
<h3 id="1-基于终点的转发"><a class="markdownIt-Anchor" href="#1-基于终点的转发"></a> 1、基于终点的转发</h3>
<ul>
<li>分组的传送和转发是基于分组首部中的目的地址的，这种转发方式称为基于终点的转发。</li>
<li>IP数据报的传送和转发过程包含以下两个过程：
<ul>
<li>主机发送IP数据报</li>
<li>路由器转发IP数据报</li>
</ul>
</li>
<li>分组每到达一个路由器，路由器就根据分组中的目的地址查找路由表。</li>
<li>路由器中的转发表是按照<strong>目的网络地址</strong>（网络前缀）来直接查找下一跳路由器的：
<ul>
<li>若按目的主机地址来制作路由表，路由表就会过于庞大。</li>
<li>若按主机所在的网络地址来制作路由表，可使路由表大大简化。</li>
</ul>
</li>
<li>根据目的网络地址就能确定下一跳路由器：
<ul>
<li>IP 数据报最终一定可以找到目的主机所在目的网络上的路由器（可能要通过多次的间接交付）。</li>
<li>只有到达最后一个路由器时，才试图向目的主机进行直接交付。</li>
</ul>
</li>
<li>路由器不转发广播IP数据报，即路由器隔离广播域。如果互联网中数量巨大的路由器收到广播IP数据报后进行转发，则会造成巨大的广播风暴，严重浪费资源。</li>
<li>主机路由（特定主机路由）
<ul>
<li>虽然互联网所有的分组转发都是基于目的主机所在的网络，但在大多数情况下都允许有这样的特例，即为特定的目的主机指明一个路由。</li>
<li>采用特定主机路由可使网络管理人员能更方便地控制网络和测试网络，同时也可在需要考虑某种安全问题时采用这种特定主机路由。</li>
<li>主机路由在转发表中都放在最前面。</li>
<li><strong>主机路由的网络前缀：a.b.c.d/32</strong></li>
</ul>
</li>
<li>默认路由（默认网关）
<ul>
<li>不管分组的目的网络在哪里，都由指定的路由器来处理。</li>
<li>采用默认路由可以减少路由表所占用的空间和搜索路由表所用的时间。</li>
<li>如果一个主机连接在一个小网络上，而这个网络只用一个路由器和互联网连接，那么在这种情况下使用默认路由是非常合适的。</li>
<li><strong>默认路由的网络前缀：0.0.0.0/0</strong></li>
</ul>
</li>
<li>两级IP地址（分类编址）下路由器分组转发算法<img src="/2024/06/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E7%BD%91%E7%BB%9C%E5%B1%82/11.png" srcset="/img/loading.gif" lazyload class="">
</li>
<li>划分子网情况下路由器分组转发算法<img src="/2024/06/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E7%BD%91%E7%BB%9C%E5%B1%82/12.png" srcset="/img/loading.gif" lazyload class="">
</li>
<li>IP 数据报的首部中没有地方可以用来指明“下一跳路由器的IP地址“。
<ul>
<li>路由器收到数据报，不是将下一跳路由器的IP地址填入IP数据报，而是送交下层的网络接口软件。</li>
<li>网络接口软件使用ARP负责将下一跳路由器的IP地址转换成硬件地址，并将此硬件地址放在链路层的MAC帧的首部，然后根据这个硬件地址找到下一跳路由器。</li>
</ul>
</li>
<li>路由表没有给分组指明到某个网络的完整路径。
<ul>
<li>路由表指出，到某个网络应当先到某个路由器（即下一跳路由器）。</li>
<li>在到达下一跳路由器后，再继续查找其路由表，知道再下一步应当到哪一个路由器。</li>
<li>这样一步一步地查找下去，直到最后到达目的网络。</li>
</ul>
</li>
<li>从 IP 地址得出网络地址：
<ul>
<li>在不划分子网的两级IP地址下，从IP地址得出网络地址是个很简单的事。</li>
<li>但在划分子网的情况下，从IP地址却不能唯一地得出网络地址来，这是因为网络地址取决于那个网络所采用的子网掩码，但数据报的首部并没有提供子网掩码的信息。</li>
</ul>
</li>
</ul>
<h3 id="2-最长前缀匹配"><a class="markdownIt-Anchor" href="#2-最长前缀匹配"></a> 2、最长前缀匹配</h3>
<ul>
<li>使用无分类编址CIDR时，路由表中的每个项目由“网络前缀”和“下一跳地址”组成。</li>
<li>在查找路由表时可能会得到不止一个匹配结果。</li>
<li>最长前缀匹配 (longest-prefix matching)：从匹配结果中选择具有最长网络前缀的路由。
<ul>
<li>最长前缀匹配又称为最长匹配或最佳匹配。</li>
<li>网络前缀越长，其地址块就越小，因而路由就越具体。</li>
</ul>
</li>
</ul>
<h3 id="3-使用二叉线索查找路由表"><a class="markdownIt-Anchor" href="#3-使用二叉线索查找路由表"></a> 3、使用二叉线索查找路由表</h3>
<ul>
<li>当路由表的项目数很大时，怎样设法减小路由表的查找时间就成为一个非常重要的问题。</li>
<li>为了进行更加有效的查找，通常是将无分类编址的路由表存放在一种层次的数据结构中，然后自上而下地按层次进行查找。</li>
<li>二叉线索 (binary trie)：一种特殊结构的树
<ul>
<li>IP 地址中从左到右的比特值决定了从根节点逐层向下层延伸的路径。</li>
<li>二叉线索中的各个路径就代表路由表中存放的各个地址。</li>
<li>为了提高二叉线索的查找速度，广泛使用了各种压缩技术。</li>
</ul>
</li>
<li>唯一前缀（unique prefix）：在表中所有的IP地址中，该前缀是唯一的。</li>
<li>
<img src="/2024/06/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E7%BD%91%E7%BB%9C%E5%B1%82/13.png" srcset="/img/loading.gif" lazyload class="">
</li>
</ul>
<h2 id="四-网际控制报文协议icmp"><a class="markdownIt-Anchor" href="#四-网际控制报文协议icmp"></a> 四、网际控制报文协议ICMP</h2>
<h3 id="1-网际控制报文协议概述"><a class="markdownIt-Anchor" href="#1-网际控制报文协议概述"></a> 1、网际控制报文协议概述</h3>
<ul>
<li>网际控制报文协议（Internet Control Message Protocol，ICMP）<strong>为了更有效地转发IP数据报以及提高IP数据报交付成功的机会</strong>，ICMP 是互联网的标准协议 [RFC 792] 。</li>
<li>主机或路由器使用ICMP来发送差错报告报文和询问报文。</li>
<li><strong>ICMP报文是装在IP数据报中</strong>，作为其中的数据部分，看起来好像是高层协议，实际是IP层协议。<img src="/2024/06/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E7%BD%91%E7%BB%9C%E5%B1%82/14.png" srcset="/img/loading.gif" lazyload class="">
</li>
</ul>
<h3 id="2-网际控制报文的种类"><a class="markdownIt-Anchor" href="#2-网际控制报文的种类"></a> 2、网际控制报文的种类</h3>
<ul>
<li>ICMP 报文的种类有两种：
<ul>
<li>ICMP 差错报告报文：用来向主机或路由器报告差错情况。</li>
<li>ICMP 询问报文：用来向主机或路由器询问情况。</li>
</ul>
</li>
</ul>
<h4 id="差错报告报文"><a class="markdownIt-Anchor" href="#差错报告报文"></a> 差错报告报文</h4>
<ul>
<li>终点不可达：当路由器或主机不能交付IP数据报时，就向源点发送终点不可达报文。
<ul>
<li>具体可再根据ICMP的代码字段细分为目的网络不可达、目的主机不可达、目的协议不可达、目的端口不可达、目的网络未知、目的主机未知等13种。</li>
</ul>
</li>
<li>源点抑制：当路由器或主机由于拥塞而丢弃IP数据报时，就向发送该IP数据报的源点发送源点抑制报文，使源点知道应当把IP数据报的发送速率放慢。</li>
<li>时间超过（超时）：当路由器收到一个目的IP地址不是自己的IP数据报时，会将其首部中生存时间TTL字段的值减1。若结果为0，路由器丢弃该数据报，向发送该IP数据报的源点发送时间超过（超时）报文。当终点在预先规定的时间内未能收到一个数据报的<strong>全部数据报分片</strong>时，就把已收到的数据报片都丢弃，也会向源点发送时间超过（超时）报文。</li>
<li>参数问题：当路由器或目的主机收到IP数据报后，根据其首部中的检验和字段的值发现首部在传送过程中出现了误码，就丢弃该数据报，并向发送该数据报的源点发送参数问题报文。</li>
<li>改变路由（重定向）：路由器把改变路由报文发送给主机，让主机知道下次应将IP数据报发送给另外的路由器，这样可以通过更好的路由到达目的主机。</li>
<li>以下情况不应发送ICMP差错报告报文：
<ul>
<li>对ICMP差错报告报文不再发送ICMP差错报告报文。</li>
<li>对第一个分片的IP数据报片的所有后续数据报片都不发送ICMP差错报告报文。</li>
<li>对具有多播地址的IP数据报都不发送ICMP差错报告报文。</li>
<li>对具有特殊地址（例如127.0.0.0或0.0.0.0）的IP数据报不发送ICMP差错报告报文。</li>
</ul>
</li>
<li><strong>所有的ICMP差错报告报文中的数据字段都具有同样的格式</strong>。</li>
</ul>
<h4 id="询问报文"><a class="markdownIt-Anchor" href="#询问报文"></a> 询问报文</h4>
<ul>
<li>回送请求或回答
<ul>
<li>由主机或路由器向一个特定的目的主机或路由器发出。</li>
<li>收到此报文的主机或路由器必须给发送该报文的源主机或路由器发送ICMP回送回答报文。</li>
<li>这种询问报文用来<strong>测试目的站是否可达以及了解其有关状态</strong>。</li>
</ul>
</li>
<li>时间戳请求或回答
<ul>
<li>用来请求某个主机或路由器回答当前的日期和时间。</li>
<li>利用在报文中的时间戳（如报文的发送时间和接收时间），发送方很容易计算出当前网络的往返时延。</li>
<li>这种询问报文用来进行时钟同步和测量时间。</li>
</ul>
</li>
</ul>
<h3 id="3-网际控制报文协议的应用举例"><a class="markdownIt-Anchor" href="#3-网际控制报文协议的应用举例"></a> 3、网际控制报文协议的应用举例</h3>
<h4 id="分组网间探测packet-internet-groperping"><a class="markdownIt-Anchor" href="#分组网间探测packet-internet-groperping"></a> 分组网间探测（Packet InterNet Groper，PING）</h4>
<ul>
<li>PING 用来测试两个主机之间的连通性。</li>
<li>PING 使用了 ICMP 回送请求与回送回答报文。</li>
<li>PING 是应用层直接使用网络层 ICMP 的例子，它没有通过运输层的TCP 或UDP。</li>
<li>某些主机或服务器为了防止恶意攻击，并会不理睬外界发来的ICMP回送请求报文。</li>
</ul>
<h4 id="跟踪路由traceroute"><a class="markdownIt-Anchor" href="#跟踪路由traceroute"></a> 跟踪路由（traceroute）</h4>
<ul>
<li>跟踪路由（traceroute）用于探测IP数据报从源主机到达目的主机要经过哪些路由器。</li>
<li>在Windows版本中，具体命令为“tracert”，其应用层直接使用网际层的ICMP协议，所使用的ICMP报文类型有回送请求和回答报文以及差错报告报文。</li>
</ul>
<h2 id="五-下一代网际协议ipv6"><a class="markdownIt-Anchor" href="#五-下一代网际协议ipv6"></a> 五、下一代网际协议IPv6</h2>
<h3 id="1-ipv6数据报的首部"><a class="markdownIt-Anchor" href="#1-ipv6数据报的首部"></a> 1、IPv6数据报的首部</h3>
<ul>
<li>IPv6 数据报由两大部分组成：
<ul>
<li>基本首部 (base header)。</li>
<li>有效载荷或净负荷（payload），允许有零个或多个扩展首部 (extension header)，再后面是数据部分。</li>
</ul>
</li>
</ul>
<img src="/2024/06/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E7%BD%91%E7%BB%9C%E5%B1%82/15.png" srcset="/img/loading.gif" lazyload class="">
<ul>
<li>IPv6将IPv4数据报首部中不必要的功能取消了，这使得IPv6数据报基本首部中的字段数量减少到只有8个。</li>
<li>IPv6地址的长度扩展到了128比特，使得IPv6数据报基本首部的长度增大到了40字节，比IPv4数据报首部固定部分的长度（20字节）增大了20字节。</li>
<li>取消了首部长度字段，因为<strong>IPv6数据报的首部长度是固定的40字节</strong>。</li>
<li>取消了区分服务（服务类型）字段，因为IPv6数据报首部中的通信量 类和流标号字段实现了区分服务字段的功能。</li>
<li>取消了总长度字段，改用有效载荷长度字段。这是因为IPv6数据报的 首部长度是固定的40字节，只有其后面的有效载荷长度是可变的。</li>
<li>取消了标识、标志和片偏移字段，因为这些功能已包含在IPv6数据报的分片扩展首部中。</li>
<li>把生存时间TTL字段改称为跳数限制字段，这样名称与作用更加一致。</li>
<li>取消了协议字段，改用下一个首部字段。</li>
<li>取消了首部检验和字段，这样可以加快路由器处理IPv6数据报的速度。</li>
<li>取消了选项字段，改用扩展首部来实现选项功能。</li>
</ul>
<h4 id="基本首部"><a class="markdownIt-Anchor" href="#基本首部"></a> 基本首部</h4>
<ul>
<li>版本：长度为4比特，用来表示IP协议的版本。对于IPv6该字段的值是6。</li>
<li>通信量类：长度为8比特，该字段用来区分不同的IPv6数据报的类别或优先级。目前正在进行不同的通信量类性能的实验。</li>
<li>流标号：长度为20比特。
<ul>
<li>IPv6提出了流的抽象概念。</li>
<li>流标号支持资源预分配。</li>
<li>“流”就是互联网上从特定源点到特定终点（单播或多播）的一系列IPv6数据报，而在这个流所经过的路径上的所有路由器都保证指明的服务质量。</li>
<li>所有属于同一个流的IPv6数据报都具有同样的流标号。</li>
<li>流标号对于实时音视频数据的传送特别有用，但对于传统的非实时数据，流标号则没有用处，把流标号字段的值置为0即可。</li>
</ul>
</li>
<li>有效载荷长度：长度为16比特，它指明IPv6数据报基本首部后面的有效载荷（包括扩展首部和数据部分）的字节数量。
<ul>
<li>该字段以字节为单位，最大取值为65535，因此IPv6数据报基本首部后面的有效载荷的最大长度为65535字节。</li>
</ul>
</li>
<li>下一个首部：长度为8比特。该字段相当于IPv4数据报首部中的协议字段或可选字段。
<ul>
<li>当IPv6数据报没有扩展首部时，该字段的作用与IPv4的协议字段一样，它的值指出了IPv6数据报基本首部后面的数据是何种协议数据单元PDU。（6——TCP、17——UDP）</li>
<li>当IPv6数据报基本首部后面带有扩展首部时，该字段的值就标识后面第一个扩展首部的类型。</li>
</ul>
</li>
<li>跳数限制：长度为8比特。该字段用来防止IPv6数据报在因特网中永久兜圈。
<ul>
<li>源点在每个IPv6数据报发出时即设定某个跳数限制（最大255跳）。</li>
<li>每个路由器在转发IPv6数据报时，先把跳数限制字段中的值减1。当跳数限制的值为0时，把这个IPv6数据报丢弃（即不转发）。</li>
</ul>
</li>
<li>源地址字段和目的地址：长度都为128比特。分别用来填写IPv6数据报的发送端的IPv6地址和接收端的IPv6地址。</li>
</ul>
<h4 id="扩展首部"><a class="markdownIt-Anchor" href="#扩展首部"></a> 扩展首部</h4>
<ul>
<li>IPv4数据报如果在其首部中使用了选项字段，则在数据报的整个传送路径中的全部路由器，都要对选项字段进行检查，这就降低了路由器处理数据报的速度。</li>
<li>实际上，在路径中的路由器对很多选项是不需要检查的。
<ul>
<li>IPv6把原来IPv4首部中选项的功能都放在扩展首部中；</li>
<li>将扩展首部留给<strong>路径两端的源站和目的站的主机来处理</strong>；</li>
<li>数据报<strong>传送路径中的所有路由器都不处理这些扩展首部</strong>（除逐跳选项扩展首部）。</li>
</ul>
</li>
<li>极大提高了路由器的处理效率。</li>
<li>在[RFC 8200]中定义了以下六种扩展首部：（1） 逐跳选项 （2） 路由选择 （3） 分片 （4） 鉴别 （5） 封装安全有效载荷 （6） 目的站选项</li>
<li>每一个扩展首部都由若干个字段组成，它们的长度也各不相同。</li>
<li><strong>所有扩展首部中的第一个字段都是“8比特的下一个首部字段”</strong>。</li>
<li>该字段的值指出在该扩展首部后面是何种扩展首部。</li>
<li>当使用多个扩展首部时，应按以上的先后顺序出现。</li>
</ul>
<h3 id="2-ipv6地址表示方法"><a class="markdownIt-Anchor" href="#2-ipv6地址表示方法"></a> 2、IPv6地址表示方法</h3>
<ul>
<li>在IPv6中，每个地址占128个比特。</li>
</ul>
<h4 id="冒号十六进制记法"><a class="markdownIt-Anchor" href="#冒号十六进制记法"></a> 冒号十六进制记法</h4>
<ul>
<li>每16比特分为1组，共8组</li>
<li>每组之间使用冒号“：”分割</li>
<li>将每组中的每4个比特转换为1个十六进制数</li>
</ul>
<h4 id="零压缩"><a class="markdownIt-Anchor" href="#零压缩"></a> 零压缩</h4>
<ul>
<li>
<p>在IPv6地址的冒号十六进制记法的基础上，再使用“左侧零”省略和“连续零”压缩，可使IPv6地址的表示更加简洁。</p>
<ul>
<li>“左侧零”省略是指两个冒号间的十六进制数中最前面的一串0可以省略不写。</li>
<li>“连续零”压缩是指一连串连续的0可以用一对冒号取代。</li>
</ul>
</li>
<li>
<p>在一个IPv6地址中<strong>只能使用一次“连续零”压缩</strong>，否则会导致歧义。</p>
</li>
<li>
<p>冒号十六进制记法还可结合点分十进制的后缀。这在IPv4向IPv6过渡阶段非常有用。</p>
<ul>
<li>0 : 0 : 0 : 0 : 0 : f f f f : 1 9 2 . 1 6 8 . 1 . 1<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">→</span></span></span></span>: : f f f f : 1 9 2 . 1 6 8 . 1 . 1</li>
</ul>
</li>
<li>
<p>CIDR的斜线表示法在IPv6中仍然可用。</p>
<ul>
<li>2 0 0 1 : 0 d b 8 : 0 0 0 0 : c d 3 0 : 0 0 0 0 : 0 0 0 0 : 0 0 0 0 : 0 0 0 0 / 6 0$\to$2 0 0 1 : d b 8 : 0 : c d 3 0 : : / 6 0</li>
</ul>
</li>
</ul>
<h3 id="3-ipv6地址的分类"><a class="markdownIt-Anchor" href="#3-ipv6地址的分类"></a> 3、IPv6地址的分类</h3>
<ul>
<li>IPv6数据报的目的地址可以是以下三种基本类型地址之一：
<ul>
<li>单播 (unicast)：传统的点对点通信。</li>
<li>多播 (multicast)：一点对多点的通信，数据报发送到一组计算机中的每一个。IPv6没有采用广播的术语，而将广播看作多播的一个特例。</li>
<li>任播 (anycast)：这是 IPv6 增加的一种类型。任播的目的站是一组计算机，但数据报在交付时只交付其中的一个，通常是距离最近的一个。</li>
</ul>
</li>
<li>IPv6将实现IPv6的主机和路由器均称为节点。
<ul>
<li>一个节点可能有多个与链路相连的接口。</li>
<li>IPv6地址是分配给节点上面的接口的（不是给某一个节点）。</li>
<li>一个具有多个接口的节点可有多个单播地址，其中的任何一个地址都可以当作到达该节点的目的地址。</li>
<li>一个节点接口的单播地址可用来唯一地标志该节点。</li>
</ul>
</li>
<li>[RFC 4291]对IPv6地址进行了分类：
<ul>
<li>未指明地址
<ul>
<li>这是16字节的全0地址，可缩写为两个冒号“::”。</li>
<li>不能用作目的地址，只能为还没有配置到一个标准的IP地址的主机当作源地址使用。</li>
<li>这类地址仅此一个。</li>
</ul>
</li>
<li>环回地址
<ul>
<li>最低比特为1，其余127个比特为全0，即0:0:0:0:0:0:0:1（记为 ::1）。</li>
<li>作用和IPv4的环回地址一样。</li>
<li>这类地址也是仅此一个。</li>
</ul>
</li>
<li>多播地址
<ul>
<li>最高8比特为全1的地址，可记为FF00::/8。</li>
<li>功能和IPv4的多播地址一样。</li>
<li>这类地址占IPv6地址总数的 1/256。</li>
</ul>
</li>
<li>本地站点单播地址（cite-local unicast address ）
<ul>
<li>最高10比特为1111111011的地址，可记为FEC0::/10。</li>
<li>内部网络上的主机使用本地站点单播地址进行通信，不能和互联网上其他主机通信。</li>
<li>其用途和IPv4的专用地址是一样的。</li>
<li>这类地址占IPv6地址总数的1/1024。</li>
</ul>
</li>
<li>本地链路单播地址 (link-local unicast address)
<ul>
<li>最高10比特为1111111010的地址，可记为FE80::/10。</li>
<li>在单一链路上使用（节点并没有连接在某个网络上）。</li>
<li>把分组发往单一链路的设备而不希望该分组被转发到此链路范围以外的地方。</li>
<li>这类地址占 IPv6 地址总数的 1/1024。</li>
</ul>
</li>
<li><strong>全球单播地址</strong>
<ul>
<li>IPv6的这一类单播地址是使用得最多的一类。</li>
<li>曾提出过多种方案来进一步划分这128位的单播地址。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="4-从ipv4向ipv6过渡"><a class="markdownIt-Anchor" href="#4-从ipv4向ipv6过渡"></a> 4、从IPv4向IPv6过渡</h3>
<h4 id="双协议栈"><a class="markdownIt-Anchor" href="#双协议栈"></a> 双协议栈</h4>
<ul>
<li>双协议栈（dual stack）：在完全过渡到IPv6之前，使一部分主机或路由器装有IPv4和IPv6两套协议栈。</li>
<li>双协议栈主机或路由器既可以和IPv6系统通信，又可以和IPv4系统通信。</li>
<li>双协议栈主机或路由器记为IPv6/IPv4，表明它具有一个IPv6地址和一个IPv4地址。
<ul>
<li>双协议栈主机在与IPv6主机通信时采用IPv6地址，而与IPv4主机通信时采用IPv4地址。</li>
<li>双协议栈主机通过域名系统DNS查询目的主机采用的IP地址：
<ul>
<li>若DNS返回的是IPv4地址，则双协议栈的源主机就使用IPv4地址；</li>
<li>若DNS返回的是IPv6地址，则双协议栈的源主机就使用IPv6地址。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="隧道技术"><a class="markdownIt-Anchor" href="#隧道技术"></a> 隧道技术</h4>
<ul>
<li>当IPv6数据报要进入IPv4网络时，将IPv6数据报重新封装成IPv4数据报，即整个IPv6数据报成为IPv4数据报的数据载荷。</li>
<li>封装有IPv6数据报的IPv4数据报在IPv4网络中传输。</li>
<li>当IPv4数据报要离开IPv4网络时，再将其数据载荷（即原来的IPv6数据报）取出并转发到IPv6网络。</li>
</ul>
<h3 id="5-网际控制报文协议icmpv6"><a class="markdownIt-Anchor" href="#5-网际控制报文协议icmpv6"></a> 5、网际控制报文协议ICMPv6</h3>
<ul>
<li>由于IPv6与IPv4一样，都不确保数据报的可靠交付，因此IPv6也需要使用网际控制报文协议ICMP来向发送IPv6数据报的源主机反馈一些差错信息。</li>
<li>ICMPv6比ICMPv4要复杂得多，它合并了原来的地址解析协议ARP和网际组管理协议IGMP的功能。</li>
<li>ICMPv6报文需要封装成IPv6数据报进行发送。</li>
<li>ICMPv6报文可被用来报告差错、获取信息、探测邻站或管理多播通信。</li>
</ul>
<h2 id="六-路由器和路由选择协议"><a class="markdownIt-Anchor" href="#六-路由器和路由选择协议"></a> 六、路由器和路由选择协议</h2>
<h3 id="1-路由器的构成和基本工作原理"><a class="markdownIt-Anchor" href="#1-路由器的构成和基本工作原理"></a> 1、路由器的构成和基本工作原理</h3>
<ul>
<li>
<p>路由器是一种具有多个输入端口和输出端口的专用计算机，其<strong>任务是转发分组</strong>。路由器是一种典型的<strong>网络层设备</strong>。</p>
</li>
<li>
<p>路由器的主要作用是：</p>
<ul>
<li>连通不同的网络。</li>
<li>选择信息传送的线路。</li>
</ul>
</li>
<li>
<p>路由器结构可划分为两大部分：</p>
<ul>
<li><strong>路由选择部分</strong>：也叫做控制部分，其核心构件是<strong>路由选择处理机</strong>。路由选择处理机的任务是根据所选定的路由选择协议构造出路由表，同时定期和相邻路由器交换路由信息而不断地更新和维护路由表。</li>
<li><strong>分组转发部分</strong>（三部分组成）：
<ul>
<li><strong>交换结构</strong> (switching fabric)：又称交换组织，是根据转发表 (forwarding table) 对分组进行处理。</li>
<li><strong>一组输入端口</strong></li>
<li><strong>一组输出端口</strong></li>
</ul>
</li>
</ul>
</li>
<li>
<p>路由选择：根据从各相邻路由器得到的关于网络拓扑变化情况，动态地改变所选择的路由。</p>
</li>
<li>
<p>分组转发：路由器根据转发表将用户的IP数据报从合适的端口转发出去。</p>
</li>
<li>
<img src="/2024/06/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E7%BD%91%E7%BB%9C%E5%B1%82/16.png" srcset="/img/loading.gif" lazyload class="">
</li>
<li>
<p>实现交换结构的三种基本方式是：通过存储器、通过总线以及通过互连网络。这三种交换结构可实现的路由器转发速率依次提高。</p>
</li>
</ul>
<h4 id="输入端口"><a class="markdownIt-Anchor" href="#输入端口"></a> 输入端口</h4>
<ul>
<li>输入端口里面装有物理层、数据链路层和网络层的处理模块。</li>
<li>数据链路层剥去帧首部和尾部后，将分组送到网络层的队列中排队等待处理。这会产生一定的时延。</li>
<li><strong>输入端口中的查找和转发功能在路由器的交换功能中是最重要的</strong>。</li>
</ul>
<h4 id="输出端口"><a class="markdownIt-Anchor" href="#输出端口"></a> 输出端口</h4>
<ul>
<li>输出端口里面装有物理层、数据链路层和网络层的处理模块。</li>
<li>输出端口从交换结构接收分组，然后把它们发送到路由器外面的线路上。</li>
<li>在网络层的处理模块中设有一个缓冲区（队列）。当交换结构传送过来的分组的速率超过输出链路的发送速率时，来不及发送的分组就必须暂时存放在这个队列中。</li>
<li>数据链路层处理模块将分组加上链路层的首部和尾部，交给物理层后发送到外部线路。</li>
<li>路由器中的<strong>输入或输出队列产生溢出</strong>是造成分组丢失的重要原因。</li>
</ul>
<h4 id="交换结构"><a class="markdownIt-Anchor" href="#交换结构"></a> 交换结构</h4>
<ul>
<li>交换结构是路由器的关键构件：把分组从一个输入端口转移到某个合适的输出端口。</li>
<li>常用交换方法有三种：
<ul>
<li>通过存储器
<ul>
<li>当路由器的某个输入端口收到一个分组时，就用中断方式通知路由选择处理机。然后分组就从输入端口复制到存储器中。</li>
<li>存储器的带宽（读或写）为每秒 M 个分组，那么路由器的交换速率（即分组从输入端口传送到输出端口的速率）<strong>一定小于 M/2</strong>。</li>
</ul>
</li>
<li>通过总线
<ul>
<li>数据报从输入端口通过共享的总线直接传送到合适的输出端口，而不需要路由选择处理机的干预。</li>
<li>路由器的转发带宽就受总线速率的限制。</li>
</ul>
</li>
<li>通过互连网络
<ul>
<li>也称为通过纵横交换结构。</li>
<li>输入端口收到分组时，就将它发送到与该输入端口相连的水平总线上。</li>
<li>若输出端口的垂直总线是空闲的，则将垂直总线与水平总线接通，将该分组转发到这个输出端口。</li>
<li>若已被占用，则后到达的分组就被阻塞，必须在输入端口排队。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="2-有关路由选择协议的基本概念"><a class="markdownIt-Anchor" href="#2-有关路由选择协议的基本概念"></a> 2、有关路由选择协议的基本概念</h3>
<ul>
<li>关于“最佳路由”：
<ul>
<li>不存在一种绝对的最佳路由算法。</li>
<li>所谓“最佳”只能是相对于某一种特定要求下得出的较为合理的选择而已。</li>
</ul>
</li>
<li>路由选择的分类（基于自适应性）
<ul>
<li>静态路由选择策略
<ul>
<li>采用人工配置的方式给路由器添加网络路由、默认路由和特定主机路由等路由条目。</li>
<li>静态路由选择简单、开销小，但不能及时适应网络状态（流量、拓扑等）的变化。</li>
<li>静态路由选择一般只在小规模网络中采用。</li>
</ul>
</li>
<li>动态路由选择策略
<ul>
<li>路由器通过路由选择协议自动获取路由信息。</li>
<li>动态路由选择比较复杂、开销比较大，但能较好地适应网络状态的变化。</li>
<li>动态路由选择适用于大规模网络。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="3-静态路由选择"><a class="markdownIt-Anchor" href="#3-静态路由选择"></a> 3、静态路由选择</h3>
<ul>
<li>
<p>默认路由</p>
<img src="/2024/06/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E7%BD%91%E7%BB%9C%E5%B1%82/17.png" srcset="/img/loading.gif" lazyload class="">
</li>
<li>
<p>特定主机路由</p>
<img src="/2024/06/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E7%BD%91%E7%BB%9C%E5%B1%82/18.png" srcset="/img/loading.gif" lazyload class="">
<ul>
<li>出于某种安全问题的考虑，同时为了使网络运维人员更方便地控制网络和测试网络，特别是在对网络的连接或路由表进行排错时，指明到某一台主机的特定主机路由是十分有用的。</li>
</ul>
</li>
</ul>
<h3 id="4-互联网分层次的路由选择协议"><a class="markdownIt-Anchor" href="#4-互联网分层次的路由选择协议"></a> 4、互联网分层次的路由选择协议</h3>
<ul>
<li>
<p>互联网路由选择协议的特点：</p>
<ul>
<li>自适应：采用动态路由选择，能较好地适应网络状态的变化。</li>
<li>分布式：各路由器通过相互间的信息交互，共同完成路由信息的获取和更新。</li>
<li>分层次：将整个因特网划分为许多较小的自治系统（Autonomous System，AS），在自治系统内部和外部采用不同类别的路由选择协议，分别进行路由选择。</li>
</ul>
</li>
<li>
<p>自治系统AS（Autonomous System，AS），在单一的技术管理下的一组路由器，而这些路由器使用一种<strong>AS内部的路由选择协议</strong>和共同的度量以确定分组在该AS内的路由，同时还使用一种<strong>AS之间的路由选择协议</strong>用以确定分组在AS之间的路由。</p>
</li>
<li>
<p>内部网关协议（Interior Gateway Protocol，IGP）：在一个自治系统内部使用的路由选择协议。</p>
</li>
<li>
<p>外部网关协议（External Gateway Protocol，EGP）：不同自治系统之间使用的路由选择协议。</p>
</li>
<li>
<p>一个AS对其他AS表现出的是一个单一的和一致的路由选择策略。</p>
</li>
<li>
<p>外部网关协议EGP和内部网关协议IGP只是路由选择协议的分类名称，而不是具体的路由选择协议。</p>
</li>
<li>
<p>在自治系统内部的路由选择叫做<strong>域内路由选择</strong>。</p>
</li>
<li>
<p>自治系统之间的路由选择也叫做<strong>域间路由选择</strong>。</p>
</li>
<li>
<p>常见的内部网关协议IGP/域内路由选择协议：RIP协议和OSPF协议。</p>
</li>
<li>
<p>常见的外部网关协议EGP/域间路由选择协议：BGP协议。</p>
</li>
</ul>
<h3 id="5-内部网关协议路由信息协议rip"><a class="markdownIt-Anchor" href="#5-内部网关协议路由信息协议rip"></a> 5、内部网关协议——路由信息协议RIP</h3>
<ul>
<li>
<p>路由信息协议RIP是一种分布式的基于距离向量（Distance-Vector，D-V）的路由选择协议。</p>
<ul>
<li>RIP要求自治系统AS内的每一个路由器，都要维护从它自己到AS内其他每一个目的网络的距离记录。</li>
<li>RIP使用跳数（Hop Count）作为度量来衡量到达目的网络的距离（“距离”指的是“最短距离”）。</li>
</ul>
</li>
<li>
<p>距离的定义：</p>
<ul>
<li>RIP将路由器到直连网络的距离定义为1。</li>
<li>RIP将路由器到非直连网络的距离定义为所经过的路由器数加1。</li>
<li>RIP允许一条路径最多包含15个路由器，距离等于16时相当于不可达（<strong>RIP只适用于小型互联网</strong>）。</li>
</ul>
</li>
<li>
<p>RIP不能在两个网络之间同时使用多条路由。</p>
</li>
<li>
<p>RIP认为，好的路由就是“距离短”的路由，也就是所通过路由器数量最少的路由，哪怕还存在另一条高速（低时延）但路由器较多的路由。</p>
</li>
<li>
<p>当到达同一目的网络有多条RIP距离相等的路由时，可以进行等价负载均衡，也就是将通信量均衡地分布到多条等价的路径上。</p>
</li>
<li>
<p>RIP协议三个特点：</p>
<ul>
<li>和谁交换信息？——仅和相邻路由器交换信息。</li>
<li>交换什么信息？——当前本路由器所知道的全部信息，即路由器的路由表（即本路由器到所在自治系统AS中各网络的最短RIP距离，以及到各网络应经过的下一跳路由器）。</li>
<li>何时交换信息？——按<strong>固定的时间间隔</strong>交换路由信息，为了加快RIP的收敛速度，当网络拓扑发生变化时，路由器要及时向相邻路由器通告拓扑变化后的路由信息，这称为<strong>触发更新</strong>。</li>
</ul>
</li>
<li>
<p>路由表的建立：</p>
<ul>
<li>自己到直连网络的RIP距离为1。</li>
<li>每个路由器仅和相邻路由器周期性地交换并更新路由信息。</li>
<li>若干次更新后，所有的路由器最终都会知道到达本AS中任何一个网络的最短距离和下一跳路由器的地址。</li>
<li>RIP 协议的收敛 (convergence) 较快，收敛就是在AS中所有的节点都得到正确的路由选择信息的过程。</li>
</ul>
</li>
<li>
<p>路由器收到相邻路由器（其地址为X）的一个RIP报文，执行如下过程：</p>
<ul>
<li>先修改此RIP报文中的所有项目：把“下一跳”字段中的地址都改为X，并把所有的“距离”字段的值加1。</li>
<li>对修改后的RIP报文中的每一个项目，重复以下步骤：
<ul>
<li>若项目中的目的网络不在路由表中，则把该项目加到路由表中。
<ul>
<li>否则，若下一跳字段给出的路由器地址是同样的，则把收到的项目替换原路由表中的项目。
<ul>
<li>否则，若收到项目中的距离小于路由表中的距离，则进行更新，
<ul>
<li>否则，什么也不做。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>除了上述RIP路由条目更新规则，在RIP的距离向量算法中还包含以下一些时间参数：</p>
<ul>
<li>路由器每隔大约30秒向其所有相邻路由器发送路由更新报文。</li>
<li>若180秒（默认）没有收到某条路由条目的更新报文，则把该路由条目标记为无效（即把RIP距离设置为16，表示不可达），若再过一段时间（如120秒），还没有收到该路由条目的更新报文，则将该路由条目从路由表中删除。</li>
</ul>
</li>
<li>
<p>RIP协议的特点：<strong>好消息传播得快，坏消息传播得慢</strong>。</p>
</li>
<li>
<p>当网络出现故障时，要经过比较长的时间（例如数分钟）才能将此信息传送到所有的路由器。</p>
</li>
<li>
<p>坏消息传播得慢的问题又被称为路由环路或RIP距离无穷计数问题。这是距离向量算法的一个固有问题。可以采取以下多种措施减少出现该问题的概率或减小该问题带来的危害：</p>
<ul>
<li>限制最大RIP距离为15（16表示不可达）。</li>
<li>当路由表发生变化时就立即发送路由更新报文（即“触发更新”），而不仅是周期性发送。</li>
<li>路由器记录收到某个路由信息的接口，不让同一路由信息再通过此接口反方向传送（即“水平分割”）。</li>
<li>使用上述措施仍无法彻底解决问题。因为在距离向量算法中，每个路由器都缺少到目的网络整个路径的完整信息，无法判断所选的路由是否出现了环路。</li>
</ul>
</li>
<li>
<p>RIP相关报文使用运输层的用户数据报协议UDP进行封装，使用的UDP端口号为520。</p>
</li>
</ul>
<img src="/2024/06/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E7%BD%91%E7%BB%9C%E5%B1%82/19.png" srcset="/img/loading.gif" lazyload class="">
<h3 id="6-内部网关协议开放最短路径优先ospf"><a class="markdownIt-Anchor" href="#6-内部网关协议开放最短路径优先ospf"></a> 6、内部网关协议——开放最短路径优先OSPF</h3>
<ul>
<li>
<p>OSPF是基于链路状态的，而不像RIP是基于距离向量的，采用分布式的链路状态协议（Link State Protocol）。</p>
</li>
<li>
<p>OSPF基于链路状态并采用最短路径算法计算路由，从算法上保证了不会产生路由环路。</p>
</li>
<li>
<p>OSPF不限制网络规模（可再划分若干小区域），更新效率高，收敛速度快。</p>
</li>
<li>
<p>OSPF协议的三个特点：</p>
<ul>
<li>向本自治系统中所有路由器发送信息，这里使用的方法是<strong>洪泛法</strong>（flooding）。
<ul>
<li>路由器通过多有输出端口向所有相邻的路由器发送信息，每一个相邻路由器又再将此信息发往其他所有的相邻路由器（除刚发来信息的那个路由器），直到所有路由器都得到了这个信息的副本。</li>
</ul>
</li>
<li>发送的信息就是与本路由器相邻的所有路由器的链路状态，但这只是路由器所知道的<strong>部分信息</strong>。
<ul>
<li><strong>“链路状态”就是说明本路由器都和哪些路由器相邻，及该链路的“度量“（metric）或“代价”</strong>。</li>
</ul>
</li>
<li>只有当链路状态发生变化或每隔一段时间，路由器才用洪泛法向所有路由器发送此信息。</li>
</ul>
</li>
<li>
<p>由于各路由器之间频繁地交换链路状态信息，因此所有的路由器最终都能建立一个<strong>链路状态数据库</strong>。</p>
</li>
<li>
<p>这个数据库实际上就是全网的拓扑结构图，它在全网范围内是一致的（这称为链路状态数据库的同步）。</p>
</li>
<li>
<p>OSPF 的链路状态数据库能较快地进行更新，使各个路由器能及时更新其路由表。</p>
</li>
<li>
<p>OSPF 的更新过程收敛得快是其重要优点。</p>
</li>
</ul>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" class="category-chain-item">计算机网络</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/%E8%AE%A1%E7%BD%91/" class="print-no-link">#计网</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>计算机网络第四章 网络层</div>
      <div>https://wyz10006.github.io/2024/06/23/计算机网络第四章-网络层/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>心逍遥</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2024年6月23日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2024/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/" title="计算机网络第三章 数据链路层">
                        <span class="hidden-mobile">计算机网络第三章 数据链路层</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  
  
    <article id="comments" lazyload>
      
  <div id="valine"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#valine', function() {
      Fluid.utils.createScript('https://lib.baomitu.com/valine/1.5.1/Valine.min.js', function() {
        var options = Object.assign(
          {"appId":"Tge3H6EIi2Wf2Gpf9l7LsHS1-gzGzoHsz","appKey":"3LOGiBjL7YN8wgXZXHDkhDZD","path":"window.location.pathname","placeholder":null,"avatar":"retro","meta":["nick","mail","link"],"requiredFields":[],"pageSize":10,"lang":"zh-CN","highlight":false,"recordIP":false,"serverURLs":"https://tge3h6ei.lc-cn-n1-shared.com","emojiCDN":null,"emojiMaps":null,"enableQQ":false},
          {
            el: "#valine",
            path: window.location.pathname
          }
        )
        new Valine(options);
        Fluid.utils.waitElementVisible('#valine .vcontent', () => {
          var imgSelector = '#valine .vcontent img:not(.vemoji)';
          Fluid.plugins.imageCaption(imgSelector);
          Fluid.plugins.fancyBox(imgSelector);
        })
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


    </article>
  


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  


  
  








    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> <div> <span id="timeDate">载入天数...</span> <span id="times">载入时分秒...</span> <script src="/js/meihua.js"></script> </div> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="leancloud-site-pv-container" style="display: none">
        总访问量 
        <span id="leancloud-site-pv"></span>
         次
      </span>
    
    
      <span id="leancloud-site-uv-container" style="display: none">
        总访客数 
        <span id="leancloud-site-uv"></span>
         人
      </span>
    
    

  
</div>

  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script defer src="/js/leancloud.js" ></script>

  <script  src="/js/local-search.js" ></script>




  
<script src="//cdn.jsdelivr.net/gh/EmoryHuang/BlogBeautify@1.1/snowflake.min.js"></script>



<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
